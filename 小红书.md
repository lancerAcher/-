###  javaScript 包括

```
完整的JavaScript包括一下几个部分：
核心：ECMAScript
文档对象模型：DOM
浏览器对象模型：BOM


```

### script 元素

```js
script 元素有下列8个属性：

async:可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。

charset:可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎他的值。

crossorigin:可选。配置相关请求的CORS（跨资源共享）设置。默认不使用CORS。

crossorgin='anonymous'配置文件请求不必设置凭据标志。crossorigin='use-credentials'设置凭据标志，意味着出站请求会包含凭据。

defer:可选。表示脚本可以延迟到文档完全被解析和显示后在执行。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。

integrity：可选。允许比对接受到的资源和指定的加密签名以及验证子资源完整性（SRI，Subresource Integrity）。如果接受道德资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。

language:废弃。最初用于表示代码块中的脚本语言（如'JavaScript'，'JavaScript 1.2'或'VBScript'）。大多数浏览器都会忽略这个属性，不应该在使用它。

src:可选。表示包含要执行的代码的外部文件。

type：可选。代替language，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是'text/javascript',尽管'text/javascript'和'text/ecmascript'都已经废弃了。JavaScript文件的MIME类型通常是'application/x-javascript',不过给type这个属性可能导致脚本被忽略。在飞IE的浏览器中有效的其他值还有'application/javascript'和'application/ecmascript'。如果这个值是module，则代码会当成ES6模块，而且只有这时候代码总才能出现 import 和 export 关键字。


```



### ES6新增数据类型 Symboll类型

```js
	Symbol(符号)是ECMAScript新增的数据类型。符号是原始值，切符号实例是唯一，不可变的。符号的用途是确保对象属性 使用唯一表示符，不会发生属性冲突的危险
	符号就是用来创建唯一记号，进而用作非字符传形式的对象属性。
	
	1.符号的基本用法：
	符号需要使用Symbol（）函数初始化，因为符号本身是原始类型，所以typeof操作符对于符号返回symbol。
	let sym = Symbol(); 
	console.log(typeof sym); // symbol
	
	调用Symbol函数时，也可以传入一个字符串作为对符号的描述，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或表示完全无关。
	
	let genericSymbol = Symbol(); 
    let otherGenericSymbol = Symbol(); 
    let fooSymbol = Symbol('foo'); 
    let otherFooSymbol = Symbol('foo'); 
    console.log(genericSymbol == otherGenericSymbol); // false
    console.log(fooSymbol == otherFooSymbol); // false
    
    符号没有字面量语法，这也是他们发挥作用的关键
	Symbol（）函数不能与new关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用Boolean，String或Number那样，他们都支持构造函数且可用于初始化包含原始值的包装对象。

        let myBoolean = new Boolean(); 
        console.log(typeof myBoolean); // "object" 
        let myString = new String(); 
        console.log(typeof myString); // "object" 
        let myNumber = new Number(); 
        console.log(typeof myNumber); // "object"
        let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
        
        如果你确实想使用符号包装对象，可以借用 Object()函数：
        let mySymbol = Symbol(); 
        let myWrappedSymbol = Object(mySymbol); 
        console.log(typeof myWrappedSymbol); // "object"
        
        2.使用全局符号注册表：
        如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。
        需要使用Symbol.for()方法：
        let fooGlobalSymbol = Symbol.for('foo'); 
		console.log(typeof fooGlobalSymbol); // symbol
		
        Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，他会检查全局运行时注册表，发现不存在对应的称号，于是就会生成一个新的符号实例并添加到注册表中。后续使用相同字符串的调用会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。
        let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
        let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
        console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
        即使采用相同的符号描述，在全局注册表中定义符号跟使用Symbol（）定义的符号也并不相同；
        let localSymbol = Symbol('foo'); 
        let globalSymbol = Symbol.for('foo'); 
        console.log(localSymbol === globalSymbol); // false
		
		全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外注册表中使用的键同时也会被用作符号描述。
        let emptyGlobalSymbol = Symbol.for(); 
		console.log(emptyGlobalSymbol); // Symbol(undefined)
		还可以使用Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符传键。如果查询的不是全局符号，则会返回undefined。
        // 创建全局符号
        let s = Symbol.for('foo'); 
        console.log(Symbol.keyFor(s)); // foo
		
		// 创建普通符号
        let s2 = Symbol('bar'); 
        console.log(Symbol.keyFor(s2)); // undefined
        如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError：
        Symbol.keyFor(123); // TypeError: 123 is not a symbol
		
		3.使用符号作为属性：
        凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。
        
         let s1 = Symbol('foo'), 
             s2 = Symbol('bar'), 
             s3 = Symbol('baz'), 
             s4 = Symbol('qux'); 
            let o = { 
             [s1]: 'foo val' 
            }; 
            // 这样也可以：o[s1] = 'foo val'; 
            console.log(o); 
            // {Symbol(foo): foo val} 
            Object.defineProperty(o, s2, {value: 'bar val'}); 
            console.log(o); 
            // {Symbol(foo): foo val, Symbol(bar): bar val} 
            Object.defineProperties(o, { 
             [s3]: {value: 'baz val'}, 
             [s4]: {value: 'qux val'} 
            }); 
            console.log(o); 
            // {Symbol(foo): foo val, Symbol(bar): bar val, 
            // Symbol(baz): baz val, Symbol(qux): qux val}
```

### 操作符

**一元操作符**：

只操作一个值的操作符叫一元操作符。一元操作符是ECMAScript中最简单的操作符。

```js
1.递增递减操作符
	递增和递减操作符直接照搬自C语言，但有两个版本。前缀版和后缀版。
	前缀版：
		无论使用前缀递增还是前缀递减操作符，变量的值都会在语句 被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）
	后缀版：
		后缀版与前缀版的主要区别在于，后缀版递增和递减在语句求值后才发生。
		let num1 = 2; 
        let num2 = 20; 
        let num3 = num1-- + num2; 
        let num4 = num1 + num2;
        console.log(num3); // 22 
		console.log(num4); // 21
	递增和递减操作符遵循如下规则：
		对于字符串，如果是有效的数值形式，则转换为数值才应用改变。变量类型从字符串变成数值。
		对于字符串，如果不是有效的数值形式，则将变量的值设置为NAN。变量类型从字符串变成数值。
		对于布尔值，如果是false，则转换为0在应用改变。变量类型从布尔值变成数值。
		对于布尔值，如果是true，则转换为1在应用改变。变量类型从布尔值变成数值。
		对于浮点值，加一或减一
		如果是对象，则调用其valueof()方法去的可以操作的值。对得到的值应用上述规则。如果是NAN则调用toString（）并再次应用其他规则。变量类型从对象变成数值。
		
```

**一元加和减**

如果将一元加应用到非数值，则会执行与Number（）转型函数一样的类型转换：布尔值falsehetrue转换为0和1，字符串根据特殊规则进行解析，对象会调用他们的valueof（）或toString（）方法可以得到可以转换的值。

**位操作符**

​	ECMAScript中的所有数值都以IEEE 754 64 位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，在进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。因此只需要考虑32为整数。

​		有符号整数使用32为的前31位表示整数值。第32为表示数值的符号，如0表示正，1表示负。这一位称为符号位，他的值决定了数值其余部分的格式。

​		正值以真正的二进制格式存储，即31位中的每一位都代表2的幂，第一位（成为第0位）表示2的0次幂，第二位表示2的1次幂。以此类推。如果一个位数是空的，则以0填充，相当于忽略不计。，数值18的二进制格式为00000000000000000000000000010010，或更精简的 10010。后者是用到的 5 个有效位，决定了实际的值

​		负值以一种称为二补数（或补码）的二进制编码存储。一个数值的二补数通过如下3个步骤计算得到：

​	1：确定绝对值的二进制表示（如，对于-18，先确定18的二进制表示）；

​	2：找到数值的一补数或者反码，换句话说iushi每个0都变成1，每个1都变成0；

​	3：给结果加1。

```js
	默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。

	在对ECMAScript中的数值应用位操作符时，后台会发生转换：64为整数会转换为32位数值，然后执行位操作，最后再把结果从32位转换为64位存储起来。整个过程就像处理32位数值一样，这让二进制操作变的与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值NAN和和Infinity在位操作上都会被当成0处理。
	如果将位操作符应用到非数值，那么首先会使用Number（）函数将该值转换为数值，这个过程是自动的，然后下应用位操作。最终结果是数值。
	
	
	1.按位非
	按位非操作符用波浪符（~）表示，他的作用是返回数值的一补数。按位非是ECMAScript中为数不多的几个二进制数学操作符之一。
	let num=25; // 二进制 00000000000000000000000000011001
	let num1=~num // 二进制 11111111111111111111111111100110
    console.log(num1) // -26
	按位非的最终效果是对数值取反并减一，如下
    let num1 = 25; 
    let num2 = -num1 - 1; 
    console.log(num2); // "-26"
	虽然两者返回结果一样，但位操作的速度快得多。这是因为为操作是在数值的底层表示上完成的。
    
    2.按位与
    按位与操作符用和好(&)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于其值表中的规则，对每一位执行相应的与操作。
              
```

![image-20210629145852324](C:\Users\Administrator\Desktop\积累\pic\image-20210629145852324.png)

​		按位与操作在两个位都是1时都返回1，在任何一位是0时返回0

​		如下操作

```js
	let result=25&3
    console.log(result)//1
	25和3的按位操作的结果是1，计算过程
    25 = 0000 0000 0000 0000 0000 0000 0001 1001 
     3 = 0000 0000 0000 0000 0000 0000 0000 0011 
    --------------------------------------------- 
    AND = 0000 0000 0000 0000 0000 0000 0000 0001
	25和3的二进制表示中，只有第0位的两个数都是1.于是结果数值的所有其他位都会以0填充，因此结果就是1。
```

**3.按位或**

```
按位或操作符用管道符(|)表示，同样有两个操作数。按位或遵循如下真值表：

```

![image-20210629150834228](C:\Users\Administrator\Desktop\积累\pic\image-20210629150834228.png)

按位或操作在至少一位是1时返回1，两位都是0时返回0。

```js
let result=25|3;
console.log(result); //27

操作如下
     25 = 0000 0000 0000 0000 0000 0000 0001 1001 
     3 = 0000 0000 0000 0000 0000 0000 0000 0011 
    --------------------------------------------- 
     OR = 0000 0000 0000 0000 0000 0000 0001 1011
在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。

```

**4.按位异或**

​	按位异或用脱字符(^)表示，同样有两个操作数。下面是按位异或的真值表

![image-20210629151444677](C:\Users\Administrator\Desktop\积累\pic\image-20210629151444677.png)

​	按位异或与按位或的区别是，它只在一位上是1的时候返回1（两位都是1或0，则返回0）。

```js
let result=25^3;
console.log(result);//26
 25 = 0000 0000 0000 0000 0000 0000 0001 1001 
 3 = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
两个数在4位上都是1，但两个数的第0位都是1，因此哪一位在结果中就变成了0.其余为上的1在另一个数上没有对应的1，因此会直接传递到结果中。二进制码11010等于26（注意，这比对同样两个执行按位或操作的到的结果小1。）
```

**5.左移**

​	左移操作符用两个小于号(<<)表示，会按照指定的位数将数值的所有位想做移动。

```js
let oldValue=2; //等于二进制10
let newValue=oldValue<<5 ; //等于二进制1000000，即十进制64
注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值。

注意：左移会保留它所操作数值的符号。

```

**6.有符号右移**

有符号右移由两个大于号(>>)表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。

```js
let oldvalue=64; //等于二进制1000000
let newvalue=oldvalue>>5 //等于二进制10，即十进制2
移位后就会出现空位。不过右移后空位会出现在左侧，且在符号位之后。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。
```

**7.无符号右移**

无符号右移用3个大于号表示(>>>),会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。

```js
let oldValue = 64; // 等于二进制 1000000 
let newValue = oldValue >>> 5; // 等于二进制 10，即十进制 2

	对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补0，而不管符号位是什么。对于正数来说，这跟有符号右移结果相同但对负数来说，结果就差太多了。无符号右移才做符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变的非常之大
    
    let oldValue = -64; // 等于二进制 11111111111111111111111111000000 
    let newValue = oldValue >>> 5; // 等于十进制 134217726 
    在对-64 无符号右移 5 位后，结果是 134 217 726。这是因为64 的二进制表示是 1111111111111111111 
    1111111000000，无符号右移却将它当成正值，也就是 4 294 967 232。把这个值右移 5 位后，结果是
    00000111111111111111111111111110，即 134 217 726。
```



### 布尔操作符

#### 1.逻辑非

​		逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布

尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。

```
换句话说，逻辑非操作符会遵循如下规则。
如果操作数是对象，则返回 false。 
如果操作数是空字符串，则返回 true。 
如果操作数是非空字符串，则返回 false。 
如果操作数是数值 0，则返回 true。 
如果操作数是非 0 数值（包括 Infinity），则返回 false。 
如果操作数是 null，则返回 true。 
如果操作数是 NaN，则返回 true。 
如果操作数是 undefined，则返回 true。
```

​		逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号(!!)，相当于调用了转型函数Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与同一个值使用Boolean()函数是一样的：

```js
console.log(!!"blue"); // true 
console.log(!!0); // false 
console.log(!!NaN); // false 
console.log(!!""); // false 
console.log(!!12345); // true
```

#### 2.逻辑与

逻辑与操作符由两个和号(&&)表示，应用到两个值

![image-20210629155035339](C:\Users\Administrator\Desktop\积累\pic\image-20210629155035339.png)

```js
逻辑与操作符可用于任何类型的操作数，不限于布尔值，如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。
	如果第一个操作数是对象，则返回第二个操作数。
    如果第二个操作数是对象，则只有第一个操作数求值为true才会返回该对象
    如果有两个操作数都是对象，则返回第二个操作数。
    如果有一个操作数是null则返回null
    如果有一个操作数是NAN则返回NAN
    如果有一个操作数是undefined则返回undefined。
    
    逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个
操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结
果也不可能等于 true。
```

####　３.逻辑或

逻辑或操作符由两个管道符（||）表示。

![image-20210629160052817](C:\Users\Administrator\Desktop\积累\pic\image-20210629160052817.png)

```js
与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如
下规则。

 如果第一个操作数是对象，则返回第一个操作数。
 如果第一个操作数求值为 false，则返回第二个操作数。
 如果两个操作数都是对象，则返回第一个操作数。
 如果两个操作数都是 null，则返回 null。  如果两个操作数都是 NaN，则返回 NaN。  如果两个操作数都是 undefined，则返回 undefined。
同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为
true，第二个操作数就不会再被求值了。
```

### 乘性操作符

​	ECMAScript定义了3个乘性操作符：**乘法，除法和取模**。这些操作符跟它们在 Java、C 语言及 Perl

中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有

不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。这意味着空字符串会

被当成 0，而布尔值 true 会被当成 1。

#### 1.乘法操作符

```
    如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或 -Infinity。
    如果有任一操作数是 NaN，则返回 NaN。
    
    如果是 Infinity 乘以 0，则返回 NaN。
    
    如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。 
    
    如果是 Infinity 乘以 Infinity，则返回 Infinity。 
    
    如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。
```

#### 2.除法操作符

```
如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正
值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。 
如果有任一操作数是 NaN，则返回 NaN。 
如果是 Infinity 除以 Infinity，则返回 NaN。 
如果是 0 除以 0，则返回 NaN。 
如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。 
如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。 
如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。
```

#### 3.取模操作符

```js
取模（余数）操作符由一个百分比符号（%）表示，比如：
let result = 26 % 5; // 等于 1 
与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为。
如果操作数是数值，则执行常规除法运算，返回余数。
如果被除数是无限值，除数是有限值，则返回 NaN。 
如果被除数是有限值，除数是 0，则返回 NaN。 
如果是 Infinity 除以 Infinity，则返回 NaN。
如果被除数是有限值，除数是无限值，则返回被除数。
如果被除数是 0，除数不是 0，则返回 0。 
如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。
```

### 指数操作符

ECMAScript7新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的；

```js
console.log(Math.pow(3, 2); // 9 
console.log(3 ** 2); // 9 
console.log(Math.pow(16, 0.5); // 4 
console.log(16** 0.5); // 4

不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作：
let squared = 3; 
squared **= 2; 
console.log(squared); // 9

let sqrt = 16; 
sqrt **= 0.5; 
console.log(sqrt); //
```

### 加性操作符

​	加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符

#### 1.加法操作符

```js
如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：
如果有任一操作数是 NaN，则返回 NaN； 
如果是 Infinity 加 Infinity，则返回 Infinity； 
如果是-Infinity 加-Infinity，则返回-Infinity； 
如果是 Infinity 加-Infinity，则返回 NaN； 
如果是+0 加+0，则返回+0；  如果是-0 加+0，则返回+0； 
如果是-0 加-0，则返回-0。
不过，如果有一个操作数是字符串，则要应用如下规则：
如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；
如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。
如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再
应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取
"undefined"和"null"。
```

### 减法操作符

```
减法操作符（-）也是使用很频繁的一种操作符

与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。
如果两个操作数都是数值，则执行数学减法运算并返回结果。
如果有任一操作数是 NaN，则返回 NaN。 
如果是 Infinity 减 Infinity，则返回 NaN。  如果是-Infinity 减-Infinity，则返回 NaN。 
如果是 Infinity 减-Infinity，则返回 Infinity。  如果是-Infinity 减 Infinity，则返回-Infinity。
如果是+0 减+0，则返回+0。 
如果是+0 减-0，则返回-0。 
如果是-0 减-0，则返回+0。  如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转
换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是
NaN。 
如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则
减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再
将得到的字符串转换为数值。
```

### 关系操作符

关系操作符执行比较两个值的操作，包括小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个操作符都返回布尔值

```
如果操作数都是数值，则执行数值比较。
如果操作数都是字符串，则逐个比较字符串中对应字符的编码。
如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。
如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。
如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。
如果有任一操作数是布尔值，则将其转换为数值再执行比较
```

### 相等操作符

```
	判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过
程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript 中的相等和不相等操
作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript
提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们
在比较之前不执行转换。
```

#### 1.等于和不等于

```
	ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于
操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进
行类型转换（通常称为强制类型转换）再确定操作数是否相等。
	在转换操作数的类型时，相等和不相等操作符遵循如下规则。
    如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换
    为 1。
    如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否
    相等。
    如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再
    根据前面的规则进行比较。
    在进行比较时，这两个操作符会遵循如下规则。
    null 和 undefined 相等。
    null 和 undefined 不能转换为其他类型的值再进行比较。
    如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两
    个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。 
    如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
    则相等操作符返回 true。否则，两者不相等
```

![image-20210629163305485](C:\Users\Administrator\Desktop\积累\pic\image-20210629163305485.png)

#### 2.全等和 不全等

​	全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操

作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true

### 赋值操作符

```
每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：
	乘后赋值（*=） 
	除后赋值（/=） 
	取模后赋值（%=） 
	加后赋值（+=） 
	减后赋值（-=） 
	左移后赋值（<<=）
    右移后赋值（>>=） 
    无符号右移后赋值（>>>=）
这些操作符仅仅是简写语法，使用它们不会提升性能。
```

### break和continue语句

​	break和continue语句为执行循环代码提供了更严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行。

#### with语句

with 语句的用途是将代码作用域设置为特定的对象，语法为：

```js
with(expression) statement;
使用with预计的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利。

let qs = location.search.substring(1); 
let hostName = location.hostname; 
let url = location.href; 
上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：
with(location) { 
 let qs = search.substring(1); 
 let hostName = hostname; 
 let url = href; 
} 
这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是
一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如
果有，则该变量会被求值为 location 对象的属性。
严格模式不允许使用 with 语句，否则会抛出错误。
```



## 原始值与引用值

​	ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。**原始值**就是最简单的数据，**引用值**则是由多个值构成的对象。

​	在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。总共有6种原始值：

Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是  **按值**访问的，因为我们操作的就是存储在变量中的实际值。

​		引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用，而非实际的对象本身。因此保存引用值的变量是按引用访问的。

```
注意：　在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例
```

###　动态属性

​	原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加修改和删除其属性和方法。

```js
let person = new Object(); 
person.name = "Nicholas"; 
console.log(person.name); // "Nicholas"

注意：原始值类型的初始化可以只是用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个object类型的实例，但其行为类似原始值。
	
```

### 复制值

原始值和引用值在通过变量复制时也有所不同。

​		在通过变量吧一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。

​		再把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，他指向存储堆内存中的对象。操作完成后两个对象实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上面反映出来

​	

### 传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中。就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值的变量复制一样。

​	在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是arguments对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存到下一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）

```js
function addTen(num) { 
 num += 10; 
 return num; 
} 
let count = 20;

let result = addTen(count); 
console.log(count); // 20，没有变化
console.log(result); // 30

ECMAScript中函数的参数就是局部变量

```

### 确定类型

​		typeof操作符最适合用来判断一个变量是否为原始类型。更确切的说，他是判断一个变量是否为字符串，数值，布尔值或者undefined的最好方式。如果值是对象或null，那么typeof返回'object'

```js
let s = "Nicholas"; 
let b = true; 
let i = 22; 
let u; 
let n = null; 
let o = new Object(); 
console.log(typeof s); // string 
console.log(typeof i); // number 
console.log(typeof b); // boolean 
console.log(typeof u); // undefined 
console.log(typeof n); // object 
console.log(typeof o); // object
```

​		typeof虽然对原始值很有用，但它对引用值的用处不大。为了解决这个问题，ECMAScript提供了instanceof操作符，语法如下。

````js
result = variable instanceof constructor

如果变量是给定引用类型（由其原型链决定）的实例，则 instanceof 操作符返回true。

console.log(person instanceof Object); // 变量 person 是 Object 吗？
console.log(colors instanceof Array); // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？

按照定义，所有引用值都是object的实例，因此通过instanceof操作符检测任何引用值和object构造函数都会返回true。类似的，如果用 instanceof 检测原始值，则始终会返回false,因为原始值不是对象。


	注意：
    typeof 操作符在用于检测函数时也会返回"function"。当在 Safari（直到 Safari 5） 和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回"function"。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在typeof 检测时返回"function"。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回"function"。在 IE 和 Firefox 中，typeof 对正则表达式返回"object"。
````

## 执行上下文与作用域

```json
	执行上下文的概念在JavaScript中是颇为重要的，变量或者函数的上下文决定了他们可以访问哪些数据，以及他们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在与这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
	
	全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的window对象，因此所有通过var定义的全局变量和函数都成为window对象的属性和方法。
	使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行 完毕后会被销毁，包括定义在它上面所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。
	每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。
	
	上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。全局上下文中没有这个变量。作用域链中的下一个变量对象来自包含上下文，在下一个对象来自在下一个包含上下文。一次类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。
	代码执行时的标识符解析是通过沿作用域链逐级搜索标识符完成的，搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有就报错）
	
```

### 作用域链增强

​		虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：

```js
try/catch 语句的 catch 块
with 语句

这两种情况下，都会在作用域链前端添加一个变量对象。对于with语句来说，会向作用域链前端添加指定的对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
function buildUrl() { 
 let qs = "?debug=true"; 
 with(location){ 
 let url = href + qs; 
 } 
 return url; 
}

这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。
buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是
location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那
个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数
上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块级作
用域（稍后介绍），所以在 with 块之外没有定义。

IE 的实现在 IE8 之前是有偏差的，即它们会将 catch 语句中捕获的错误添加到执
行上下文的变量对象上，而不是 catch 语句的变量对象上，导致在 catch 块外部都可以
访问到错误。IE9 纠正了这个问题。
```

### 变量声明

ES6之后，增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var成为首选。

#### 1.使用var的函数作用域声明

​		在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，



​	**注意**未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。

为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量

会报错。

#### 2. 使用 **let** 的块级作用域声明

​		ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念。块

级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独

的块也是 let 声明变量的作用域。



​		let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重

复的 let 声明会抛出 SyntaxError。

​		let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情

况应该避免。

​		严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提升跟 var是不一样的。

#### 3. 使用 **const** 的常量声明

​		除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。

一经声明，在其生命周期的任何时候都不能再重新赋予新值

​		const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值

为其他引用值，但对象的键则不受限制。

​		如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，

但会静默失败：

```js
const o3 = Object.freeze({}); 
o3.name = 'Jake'; 
console.log(o3.name); // undefined
```



​		由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。

​		

​		**注意**：开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug

### 标识符查找

​		当在特定上下文中为读取或写入而引用的一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前段，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。

```js
var color = 'blue'; 
function getColor() { 
 return color; 
} 
console.log(getColor()); // 'blue'
```

​	对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符，如下面的例子所示：

```js
var color = 'blue'; 
function getColor() { 
 let color = 'red'; 
 return color; 
} 
console.log(getColor()); // 'red'

使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次：
var color = 'blue'; 
function getColor() { 
 let color = 'red'; 
 { 
 let color = 'green'; 
 return color; 
 } 
} 
console.log(getColor()); // 'green'


注意 标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用
域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不
足道了。

```

### 垃圾回收

​		JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和c++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：**确定哪个变量不会再使用，然后释放它占用的内存**。这个过程是周期性的，即垃圾回收程序每隔一段时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于不可判断的问题，意味着靠算法是解决不了的。

​		我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，**栈或者堆内存会分配空间以保存相应的值。函数在内部使用了变量然后退出，此时，就不需要那个局部变量了，它占用的内存可以释放，供后面使用。**这种情况下显然不在需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过在浏览器的发展史上，用到过两种主要的表及策略：标记清理和引用计数。

####　标记清理

​			JavaScript最常用的的垃圾回收策略是，**标记清理**。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远也不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

​		给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护在上下文中和不在上下文中两个变量列表，可以吧变量从一个列表转移到另一个列表标记过程的实现并不重要，关键是策略。

​			垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后他会将所有在上下文中的变量，以及被在上下文中的变量引用的变量标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存。

​			到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。

#### 引用计数

​		另一种没那么常用的垃圾回收策略是引用计数。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1.类似的，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没办法在访问到这个值了，因此可以安全的回收其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。

​		引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如

```js
function problem() { 
 let objectA = new Object(); 
 let objectB = new Object(); 
 objectA.someOtherObject = objectB; 
 objectB.anotherObject = objectA; 
}
```

​		在这个例子中，objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在

标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。为此，Netscape 在 4.0 版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。



​		在 IE8 及更早版本的 IE 中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 C++实现的组件对象模型（COM，Component Object Model）对象，而 COM 对象使用引用计数实现垃圾回收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM对象的循环引用问题：

```js
let element = document.getElementById("some_element"); 
let myObject = new Object(); 
myObject.element = element; 
element.someObject = myObject;

	这个例子在一个 DOM 对象（element）和一个原生 JavaScript 对象（myObject）之间制造了循环
引用。myObject 变量有一个名为 element 的属性指向 DOM 对象 element，而 element 对象有一个
someObject 属性指回 myObject 对象。由于存在循环引用，因此 DOM 元素的内存永远不会被回收，
即使它已经被从页面上删除了也是如此。
	为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之
间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：
myObject.element = null; 
element.someObject = null; 
	把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，
这些值就会被删除，内存也会被回收。
	为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象
```

#### 性能

​		垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发之不知道什么时候运行时会收集垃圾，因此最好的办法是写代码时就要做到：无论什么时候开始收集垃圾，都能让他尽快结束工作。

​		现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如根据v8团队2016年的一篇博文的说法：**再一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量在外籍一些余量来确定何时再次垃圾回收。**

​		

#### 内存管理

​		在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。者更多处于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页好近系统

#### 正则表达式的模式局限

​	虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然确实Perl语言中的一些高级特性。下列特性目前还没有得到ECMAScript的支持

\A和\z锚(分别匹配字符串的开始和末尾)

联合及交叉类

原子组

x(忽略空格)匹配模式

条件式匹配

正则表达式注释 

虽然还有这些局限，但ECMAScript的正则表达式已经非常强大，可以用于大多数匹配任务

### 原始值包装类型

​	为了方便操作原始值，ECMAScript提供了三种特殊的引用类型：Boolean，Number和String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对象的特殊行为。每当用到某个原始值的方法或者属性时，后台就会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。

```js
实例
let　s1='some text';
let  s2=s1.substring(2);
 当第二行访问s1的时候，是以读模式访问的名也就是要从内存中读取变量保存的值，在已读模式访问字符串值的时候，后台都会执行以下3步
 1.创建一个String类型的实例
 2.调用实例上的特定方法
 3.销毁实例
 可以将这三部想象为如下方法
 let s1=new String('some text');
 let s2=s1.substring(2)
 s1=null;

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上三部也会在后台发生，只不过使用的是Boolean和Number包装类型而已

引用类型与原始值的包装类型的主要区别在于对象的生命周期，在通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动穿件的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法

例如：
let s1 = "some text"; 
s1.color = "red"; 
console.log(s1.color); // undefined
这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。可是，第三行代码访问 color 属性时，它却不见了。原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。

可以显示地使用Boolean，Number，和String构造函数创建原始值包装对象。不过应该在确实必要时在这么做，否则容易让开发者疑惑，分不清他们到底是原始值还是引用值。在原始值包装类型的实例上调用typeof 会返回 object 所有的原始值包装对象都会转换为布尔值true。

另外，object构造函数作为一个工厂方法，能够根据传入值的类型返回相应对应原始值包装类型的实例
let obj = new Object("some text"); 
console.log(obj instanceof String); // true
如果传给object的是字符串，则会创建一个String的实例。如果是数值，则会创建Number的实例，布尔值则会得到Boolean的实例

注意：使用new 调用原始值包装类型的构造函数，与调用同名的转型函数不一样。
let value = "25"; 
let number = Number(value); // 转型函数
console.log(typeof number); // "number" 
let obj = new Number(value); // 构造函数
console.log(typeof obj); // "object"
变量number 中保存的是一个值为25的原始数值，而变量obj中保存的是一个Number的实例。

```

Number，Boolean类型重写了valueOf(),toLocaleString()和toString()方法。valueOf方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选的接收一个表示基数的参数，并返回相应基数形式的数值字符串。

```js
let num = 10; 
console.log(num.toString()); // "10" 
console.log(num.toString(2)); // "1010" 
console.log(num.toString(8)); // "12" 
console.log(num.toString(10)); // "10" 
console.log(num.toString(16)); // "a"
除了继承的方法，Number类型还提供了几个用于将数值格式化为字符串的方法。
toFoxed()方法返回包含指定小数点位数的数值字符串 
let num = 10; 
console.log(num.toFixed(2)); // "10.00"
如果数值本身的小数位超过了参数指定的位数，则四舍五入到最近的小数位
let num = 10.005; 
console.log(num.toFixed(2)); // "10.01" 

toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定
得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。
注意：toFixed()方法可以表示有0-20个小数的数值，某些浏览器可能支持更大范围，但这是通常被支持的范围。

另一个用于格式化数值的方法是toExponential()返回科学计数法(也称为指数计数法)表示的数值字符串。与toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。
let num = 10; 
console.log(num.toExponential(1)); // "1.0e+1"

这段代码的输出为"1.0e+1"。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数
值最适当的形式，那么可以使用 toPrecision()。
toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法
形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：
let num = 99; 
console.log(num.toPrecision(1)); // "1e+2" 
console.log(num.toPrecision(2)); // "99" 
console.log(num.toPrecision(3)); // "99.0" 
在这个例子中，首先要用 1 位数字表示数值 99，得到"1e+2"，也就是 100。因为 99 不能只用 1 位
数字来精确表示，所以这个方法就将它舍入为 100，这样就可以只用 1 位数字（及其科学记数法形式）
来表示了。用 2 位数字表示 99 得到"99"，用 3 位数字则是"99.0"。本质上，toPrecision()方法会
根据数值和精度来决定调用 toFixed()还是 toExponential()。为了以正确的小数位精确表示数值，
这 3 个方法都会向上或向下舍入。

toPrecision()方法可以表示带 1~21 个小数位的数值。某些浏览器可能支持更大
的范围，但这是通常被支持的范围。


```

#####　isInteger()方法与安全整数

```js
ES6新增了Number.isInteger()方法,用于辨别一个数值是否保存为整数,有时候，小数位的0可能会让人误以为数值是一个浮点值。

console.log(Number.isInteger(1)); // true 
console.log(Number.isInteger(1.00)); // true 
console.log(Number.isInteger(1.01)); // false


```

##### string 的方法

```js
ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、
endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含
的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索
引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：
let message = "foobarbaz"; 
console.log(message.startsWith("foo")); // true 
console.log(message.startsWith("bar")); // false 
console.log(message.endsWith("baz")); // true 
console.log(message.endsWith("bar")); // false 
console.log(message.includes("bar")); // true 
console.log(message.includes("qux")); // false

startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二
个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是
一个例子：
let message = "foobarbaz"; 
console.log(message.startsWith("foo")); // true 
console.log(message.startsWith("foo", 1)); // false 
console.log(message.includes("bar")); // true 
console.log(message.includes("bar", 4)); // false 
endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，
那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：
let message = "foobarbaz"; 
console.log(message.endsWith("bar")); // false 
console.log(message.endsWith("bar", 6)); // true
```

######　repeat 方法

```js
ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字
符串复制多少次，然后返回拼接所有副本后的结果。
let stringValue = "na "; 
console.log(stringValue.repeat(16) + "batman"); 
// na na na na na na na na na na na na na na na na batman
```

###### padStart()和padEnd()方法

```js
padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至
满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格
（U+0020）。
let stringValue = "foo"; 
console.log(stringValue.padStart(6)); // " foo" 
console.log(stringValue.padStart(9, ".")); // "......foo" 
console.log(stringValue.padEnd(6)); // "foo " 
console.log(stringValue.padEnd(9, ".")); // "foo......" 
可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配
指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。
let stringValue = "foo"; 
console.log(stringValue.padStart(8, "bar")); // "barbafoo" 
console.log(stringValue.padStart(2)); // "foo" 
console.log(stringValue.padEnd(8, "bar")); // "foobarba" 
console.log(stringValue.padEnd(2)); // "foo"
```

#### eval() 方法

```js
eval()方法一个完整的ECMAScript解释器，它接受一个参数，即一个要执行的ECMAScript(JavaScript)字符串
例如
eval("console.log('hi')"); 
上面这行代码的功能与下一行等价：
console.log("hi");
当解释器发现eval()调用时，会将参数解释为实际的ECMAScript语句，然后将其插入到该位置。通过eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链，这意味着定义在包含上下文的变量可以在eval()调用内部使用，
let msg = "hello world"; 
eval("console.log(msg)"); // "hello world"

变量 msg 是在 eval()调用的外部上下文中定义的，而 console.log()显示了文本"hello world"。这是因为第二行代码会被替换成一行真正的函数调用代码。类似地，可以在 eval()内部定义一个函数或变量，然后在外部代码中引用

eval("function sayHi() { console.log('hi'); }"); 
sayHi();
函数 sayHi()是在 eval()内部定义的。因为该调用会被替换为真正的函数定义，所以才可
能在下一行代码中调用 sayHi()。对于变量也是一样的：
eval("let msg = 'hello world';"); 
console.log(msg); // Reference Error: msg is not defined 
通过 eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 eval()执行的时候才会被创建。
在严格模式下，在 eval()内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报
错。同样，在严格模式下，赋值给 eval 也会导致错误：
"use strict"; 
eval = "hi"; // 导致错误

注意：
解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。
```

##### 数组的from()和of()方法

Array 构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例,而of()用于将一组参数转换为数组实例。

数组最多可以包含 4 294 967 295 个元素

**检测数组的方法**

```js
判断一个对象是不是一个数组,在只有一个网页(因而只有一个全局作用域)大情况下,使用instanceof操作符。
if(value instanceof Array){
    操作数组
}
使用instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及到两个不同的全局执行上下文，因此就会有两个不同版本的Array构造函数。如果要吧数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。(当数组希望通过两个作用域进行传播时，会出错)

为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：
if (Array.isArray(value)){ 
 // 操作数组
}

```

```js
迭代器方法
 
在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和
entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回
索引/值对的迭代器：
const a = ["foo", "bar", "baz", "qux"]; 
// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过 Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys()); 
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries()); 
console.log(aKeys); // [0, 1, 2, 3] 
console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]] 
使用 ES6 的解构可以非常容易地在循环中拆分键/值对：
const a = ["foo", "bar", "baz", "qux"]; 
for (const [idx, element] of a.entries()) { 
 alert(idx); 
 alert(element); 
} 
// 0 
// foo 
// 1 
// bar 
// 2 
// baz 
// 3 
// qux
```

#####　复制和填充方法

```js
	ES6新增了两个方法:批量复制方法 copyWithin(),以及填充数组方法 fill()。
这两个方法的函数签名类似，都需要指定既有数组实例的一个范围，包括开始索引，不包含结束索引，使用这个方法不会改变数组的大小。
fill()
	使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想像成数组长度加上它得到的一个正索引。
const zeroes = [0, 0, 0, 0, 0]; 
// 用 5 填充整个数组
zeroes.fill(5); 
console.log(zeroes); // [5, 5, 5, 5, 5] 
zeroes.fill(0); // 重置
// 用 6 填充索引大于等于 3 的元素
zeroes.fill(6, 3); 
console.log(zeroes); // [0, 0, 0, 6, 6] 
zeroes.fill(0); // 重置
// 用 7 填充索引大于等于 1 且小于 3 的元素
zeroes.fill(7, 1, 3); 
console.log(zeroes); // [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 重置
// 用 8 填充索引大于等于 1 且小于 4 的元素
// (-4 + zeroes.length = 1) 
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];

fill()静默忽略超出数组边界，零长度及方向相反的索引范围：
const zeroes = [0, 0, 0, 0, 0]; 
// 索引过低，忽略
zeroes.fill(1, -10, -6); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引过高，忽略
zeroes.fill(1, 10, 15); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引反向，忽略
zeroes.fill(2, 4, 2); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引部分可用，填充可用部分
zeroes.fill(4, 3, 10) 
console.log(zeroes); // [0, 0, 0, 4, 4]

	与fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入指定索引开始的位置。开始索引和结束索引则与fill()使用同样的计算方法

    let ints, 
 	reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
	reset();
// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5); 
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] 
reset(); 
// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3); 
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset(); 
// JavaScript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6); 
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset(); 
// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3); 
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] 
copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：
let ints, 
 reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 索引过低，忽略
ints.copyWithin(1, -15, -12); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset() 
// 索引过高，忽略
ints.copyWithin(1, 12, 15); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 索引反向，忽略
ints.copyWithin(2, 4, 2); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10) 
alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
```

##### 数组的操作方法

```js
concat()方法可以在现有数组全部元素的基础上创建一个新的数组。它首先会创建一个当前数组的副本，然后在把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则concat()会吧这些数组的每一项都添加到结果数组。
如果参数不是数组，则直接吧它们添加到结果数组末尾。(数组拼接)


打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止concat()打平参数数组。相反，把这个值设置为true可以强制打平类数组对象;
let colors = ["red", "green", "blue"]; 
let newColors = ["black", "brown"]; 
let moreNewColors = { 
 [Symbol.isConcatSpreadable]: true, 
 length: 2, 
 0: "pink", 
 1: "cyan" 
}; 
newColors[Symbol.isConcatSpreadable] = false; 
// 强制不打平数组
let colors2 = colors.concat("yellow", newColors); 
// 强制打平类数组对象
let colors3 = colors.concat(moreNewColors); 
console.log(colors); // ["red", "green", "blue"] 
console.log(colors2); // ["red", "green", "blue", "yellow", ["black", "brown"]] 
console.log(colors3); // ["red", "green", "blue", "pink", "cyan"]
```

##### 数组的归并方法

```js
ECMAScript为数组提供了两个归并方法:reduce()和reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而reduceRight()从最后一项开始遍历至第一项

这两个方法都能接受两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值，传给reduce()和reduceRight()的函数接受4个参数：上一个归并值，当前项，当前项的索引和数组本身。这个函数按返回的任何值都会作为下载一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数(作为归并起点值),则第一次迭代奖惩数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。


可以使用 reduce()函数执行累加数组中所有数值的操作，比如：
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduce((prev, cur, index, array) => prev + cur); 
alert(sum); // 15 
第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数
组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。
reduceRight()方法与之类似，只是方向相反。来看下面的例子：
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduceRight(function(prev, cur, index, array){ 
 return prev + cur; 
}); 
alert(sum); // 15

在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。当然，最终结果相同，因为归并操作都
是简单的加法。
究竟是使用 reduce()还是 reduceRight()，只取决于遍历数组元素的方向。除此之外，这两个
方法没什么区别。
```

#### 定型数组

```
定型数组(typed array)是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有"TypeArray"类型，它所指的其实是一种特殊的包含数值类型的数组。
```

### Map

```js
	ECMAScript 6 以前，在JavaScript中实现'键/值'式存储可以使用object 来方便高效的完成，也就是使用对象属性作为键，在使用属性来引用值。但这种实现并非没有问题。
	为此TC39委员会专门为'键/值'存储定义了一个规范
    
    作为ECMAScript 6 的新增特性，map 是一种新的集合类型，为这门语言带来了真正的键/值存储机制。map的大多数特性都可以通过object类型实现，但二者之间还是存在一些细微的差异。

基本API
	使用new 关键字和Map构造函数可以创建一个空映射
    const m = new Map()
    如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中。
// 使用嵌套数组初始化映射
const m1 = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
alert(m1.size); // 3 
// 使用自定义迭代器初始化映射
const m2 = new Map({ 
 [Symbol.iterator]: function*() { 
 yield ["key1", "val1"]; 
 yield ["key2", "val2"]; 
 yield ["key3", "val3"]; 
 } 
}); 
alert(m2.size); // 3 
// 映射期待的键/值对，无论是否提供
const m3 = new Map([[]]); 
alert(m3.has(undefined)); // true 
alert(m3.get(undefined)); // undefined

初始化之后，可以使用 set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询，可
以通过 size 属性获取映射中的键/值对的数量，还可以使用 delete()和 clear()删除值。

const m = new Map(); 
alert(m.has("firstName")); // false 
alert(m.get("firstName")); // undefined 
alert(m.size); // 0

get()和has()的区别 get()获取的是键值对的值，如果没有则为undefined has()则为判断是否含有该键值对，返回 true 或者 false

m.set("firstName", "Matt") 
 .set("lastName", "Frisbie"); 
alert(m.has("firstName")); // true 
alert(m.get("firstName")); // Matt 
alert(m.size); // 2

m.delete("firstName"); // 只删除这一个键/值对
alert(m.has("firstName")); // false 
alert(m.has("lastName")); // true 
alert(m.size); // 1 
m.clear(); // 清除这个映射实例中的所有键/值对
alert(m.has("firstName")); // false 
alert(m.has("lastName")); // false 
alert(m.size); // 0

set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：
const m = new Map().set("key1", "val1"); 
m.set("key2", "val2") 
 .set("key3", "val3"); 
alert(m.size); // 3


与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为
键。Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相
当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的

'注意：'此处的键意思就是变量名
const m = new Map(); 
const functionKey = function() {}; 
const symbolKey = Symbol(); 
const objectKey = new Object(); 
m.set(functionKey, "functionValue"); 
m.set(symbolKey, "symbolValue"); 
m.set(objectKey, "objectValue"); 
alert(m.get(functionKey)); // functionValue 
alert(m.get(symbolKey)); // symbolValue 
alert(m.get(objectKey)); // objectValue 
// SameValueZero 比较意味着独立实例不冲突
alert(m.get(function() {})); // undefined

与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时
仍然保持不变：
'理解:在修改的变量名，即参数进行改变的情况下，他的值会改变，但是参数名意思就是变量名不会做出改变(有可能是因为本质的指针指向的地址内容也同步改变了)' 
const m = new Map(); 
const objKey = {}, 
 objVal = {}, 
 arrKey = [], 
 arrVal = []; 
m.set(objKey, objVal); 
m.set(arrKey, arrVal); 
objKey.foo = "foo"; 
objVal.bar = "bar"; 
arrKey.push("foo"); 
arrVal.push("bar"); 
console.log(m.get(objKey)); // {bar: "bar"} 
console.log(m.get(arrKey)); // ["bar"]

SameValueZero 比较也可能导致意想不到的冲突：
'理解:当他进行比较的时候有可能是按照字符传进行比较，意思就是当两者意义为相等的时候，得到的结果就是相同的，转义符这些东西 可以理解为js的相等'
const m = new Map(); 
const a = 0/"", // NaN 
 b = 0/"", // NaN 
 pz = +0, 
 nz = -0;
alert(a === b); // false 
alert(pz === nz); // true 
m.set(a, "foo"); 
m.set(pz, "bar"); 
alert(m.get(b)); // foo 
alert(m.get(nz)); // bar
```

#### Map 的顺序与迭代

```js
	'与object类型的一个主要差异是',Map实例会回味键值对的插入顺序，因此可以根据插入顺序执行迭代操作。
	映射实例可以提供一个迭代器(Iterator),能以插入顺序生成[key,value]形式的数组。可以通过entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器：
    
    
    const m = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
alert(m.entries === m[Symbol.iterator]); // true 
for (let pair of m.entries()) { 
 alert(pair); 
} 
// [key1,val1] 
// [key2,val2] 
// [key3,val3] 
for (let pair of m[Symbol.iterator]()) { 
 alert(pair); 
} 
// [key1,val1] 
// [key2,val2] 
// [key3,val3] 
因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：
const m = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]] 
如果不使用迭代器，而是使用回调方式，则可以调用映射forEach(callback,opt_thisArg)
方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：
'理解: 可以进行一些数组的操作 不过 val(第一个参数) 是键名 key(第二个参数) 是键值'
const m = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
m.forEach((val, key) => alert(`${key} -> ${val}`)); 
// key1 -> val1 
// key2 -> val2 
// key3 -> val3 
keys()和 values()分别返回以插入顺序生成键和值的迭代器：
const m = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
for (let key of m.keys()) { 
 alert(key); 
} 
// key1 
// key2 
// key3 
for (let key of m.values()) { 
 alert(key); 
} 
// value1 
// value2 
// value3


键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为
键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：
const m1 = new Map([ 
 ["key1", "val1"] 
]); 
// 作为键的字符串原始值是不能修改的
for (let key of m1.keys()) { 
 key = "newKey"; 
 alert(key); // newKey 
 alert(m1.get("key1")); // val1 
} 
const keyObj = {id: 1}; 
const m = new Map([ 
 [keyObj, "val1"] 
]); 
// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值
for (let key of m.keys()) { 
 key.id = "newKey"; 
 alert(key); // {id: "newKey"} 
 alert(m.get(keyObj)); // val1 
} 
alert(keyObj); // {id: "newKey"}
```

### 选择 Object 还是Map

```js
1.内存占用
	Object和Map的工程级实现在不同浏览器之间存在明显差异，但存储单个键值对所占用的内才能都会随键的数量线性增加，批量添加或者删除键值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map大约可以比Object多存储50%的键值对。
2.插入性能
	向Object和Map中插入新键值对的消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键值对数量而线性增加。如果代码涉及大量插入操作，那么显然Map的性能更佳。
3.查找速度
	与插入不同，从大型的Object和Map中查找键值对的性能差异极小，但如果只包含少量键值对，则Object有时候速度更快，早吧Object当成数组使用的情况下(比如使用连续整数作为属性),浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言，查找速度不会随着键值对数量增加而线性增加。如果代码涉及大量查操作，那么某些情况下可能选择Object更好一点。
4.删除性能
使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。
```

### weakMap

```js
ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。

'基本API'
通过new 关键字实例化 一个空的 WeakMap
const wm = new WeakMap();
弱映射中的键只能是Object或者继承来自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。

```



