### 后端传递的为base64码前段如何解决

```
<image :src="list.base64Str" mode=""></image>
数据获取时在数据前面添加字段
this.list.base64Str='data:image/png;pang;base64,'+this.list.base64Str

```

### element 给input框加单位

```
使用插槽解决
<el-form-item label="温度:"  class="layout">
     <el-input v-model="form.temperature" placeholder="工艺温度" ><i slot="suffix" style="font-style:normal;margin-right: 10px;">℃</i></el-input>
</el-form-item>
```

#### js：把字符串转为变量使用； js下将字符串当函数去执行的方法

```js
1 把字符串当变量使用
demo:
var type = "car";
var newStr = "type";
var x = 100;

eval("2+2");
eval("type");
eval("x + 17");
console.log(eval("2+2"), eval("type"), eval("x + 17"));
运算结果：
4 "car" 117

2  js下将字符串当函数去执行的方法

    function getWord(Word) {
      alert(Word);
    }


    window["getText"]("方法一");
    eval('getText("方法二")');


结果：
出现“方法一”，“方法二”的弹窗。
 

3  同时window["getText"]("方法一"); 是通过字符串读取对象key的方法。
```

### 关于普通jsp/html页面适配手机端的改造

```js
普通页面需要适配手机端.页面上加上这几句即可适配.其他不用改
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="format-detection" content="telephone=no"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black"/>

```

#### 微信公众号页面关闭

微信JS-SDK说明文档 https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#1

```js
WeixinJSBridge.call("closeWindow")
此方法为浏览器内置方法，直接调用即可

```

### jsp ftom表单序列化

```js
序列化之后的结果：“&person.name=张三（这里中文会被编码)&person.sex=1&person.age=1”
由此可见被display修饰的元素也会被序列化,没有name属性的input框不会被序列化，因为序列化的本质是key-value的形式
$('#baseForm').serialize()

serializeArray方法
可以将表单序列化成一个特殊的json数组,带有name和value的json。
$(".btn3").click(function(){
		var data ={}
		$("form").serializeArray().map(function(val,key){
			data[val.name]=val.value;
		})
		console.log(data);
	})
```

#### 防抖和节流

```js
'区别'
1.防抖:在函数被触发的n秒内，如果又被触发，就会重新计时。
var timer;
function debounce(fn, delay) {
      clearTimeOut(timer);
      timer = setTimeout(function(){
            fn();
      }, delay);
}
/*
* fn [function] 需要防抖的函数
* delay [number] 毫秒，防抖期限值
*/
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时
            timer = setTimeout(fn,delay) 
        }else{
            timer = setTimeout(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时
        }
    }
}


/*****************************简化后的分割线 ******************************/
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop,1000) // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置


'应用场景'：

在input框中输入搜索内容的时候，浏览器不会马上就去执行，
手机号、邮箱输入验证；
窗口大小resize，只需要调整完成后，计算窗口大小，防止重复渲染


'节流':每隔一段时间，只执行一次函数

function throttle(fn, delay) {
      const previous = 0;
      return function() {
            const _this = this;
            const args = arguments;
            const now = new Date();
            if (now - previous > delay) {
                fn.apply(_this, args);
                previous = now;
            }
      }
}

function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */

// 以下照旧
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = throttle(showTop,1000) 
```



#### js对象转成用&拼接的请求参数

```js

var parseParam=function(param, key){
var paramStr="";
if(param instanceof String||param instanceof Number||param instanceof Boolean){
paramStr+="&"+key+"="+encodeURIComponent(param);
}else{
$.each(param,function(i){
var k=key==null?i:key+(param instanceof Array?"["+i+"]":"."+i);
paramStr+='&'+parseParam(this, k);
});
}
return paramStr.substr(1);
};
 
 
 
 
 
var obj={name:'tom','class':{className:'class1'},classMates:[{name:'lily'}]};
parseParam(obj);
结果："name=tom&class.className=class1&classMates[0].name=lily"
parseParam(obj,'stu');
结果："stu.name=tom&stu.class.className=class1&stu.classMates[0].name=lily"


            parseParam(param, key=null){
                let that=this
                var paramStr="";
                if(param instanceof String||param instanceof Number||param instanceof Boolean){
                    paramStr+="&"+key+"="+encodeURIComponent(param);
                }else{
                    $.each(param,function(i){
                        var k=key==null?i:key+(param instanceof Array?"["+i+"]":"."+i);
                        paramStr+='&'+that.parseParam(this, k);
                    });
                }
                return paramStr.substr(1);
            },
```



### 阻止冒泡

```
在事件后增加.stop
```

### 查看是否可以访问ip地址

```
C:\Users\Administrator>ping 192.168.1.142

正在 Ping 192.168.1.142 具有 32 字节的数据:
来自 192.168.1.183 的回复: 无法访问目标主机。
来自 192.168.1.183 的回复: 无法访问目标主机。
来自 192.168.1.183 的回复: 无法访问目标主机。
来自 192.168.1.183 的回复: 无法访问目标主机。

192.168.1.142 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
```

### 获取网站域名

```
//获取域名
host = window.location.host;
host2=document.domain;
 
//获取页面完整地址
url = window.location.href;

```

#### vuex中 this.$store.dispatch() 与 this.$store.commit()方法的区别

```js
this.$store.dispatch() 与 this.$store.commit()方法的区别总的来说他们只是存取方式的不同,两个方法都是传值给vuex的mutation改变state
this.$store.dispatch() ：含有异步操作，例如向后台提交数据，写法：this.$store.dispatch(‘action方法名’,值)
this.$store.commit()：同步操作，，写法：this.$store.commit(‘mutations方法名’,值)

commit: 同步操作

存储 this.$store.commit('changeValue',name)
取值 this.$store.state.changeValue

dispatch: 异步操作

存储 this.$store.dispatch('getlists',name)
取值 this.$store.getters.getlists
```

### [provide / inject](https://cn.vuejs.org/v2/api/#provide-inject)孙组件传递爷组件

```
使用场景：vue有$parent属性可以让子组件访问父组件。但子孙组件想要访问祖先组件就比较困难。这时候可以通过provide/inject来实现跨级访问祖先组件的数据。

provide / inject 是在 VUE 2.2.0 的版本新增的

类型：
provide: Object | () => Object
provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作
inject: Array<String> | { [key:string]:  string | symbol | Object }
提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的
注意： provide 和 inject 主要在开发高阶插件/组建库时使用。并不推荐用于普通应用程序代码中
```

### Promise的then的第二个参数和catch的区别

```js
首页要区分几个概念：
第一，reject是用来抛出异常的，catch是用来处理异常的；
第二：reject是Promise的方法，而then和catch是Promise实例的方法（Promise.prototype.then 和 Promise.prototype.catch）。

1.区别
主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。
catch只是一个语法糖而已，还是通过then来处理的，大概如下
Promise.prototype.catch = function(fn){
    return this.then(null,fn);
}
then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。
const promise = new Promise((resolve, rejected) => {
    throw new Error('test');
});

//此时只有then的第二个参数可以捕获到错误信息
promise.then(res => {
    //
}, err => {
    console.log(err);
}).catch(err1 => {
    console.log(err1);
});


//此时catch方法可以捕获到错误信息
promise.then(res => {
    //
}).catch(err1 => {
    console.log(err1);
});


//此时只有then的第二个参数可以捕获到Promise内部抛出的错误信息
promise.then(res => {
    throw new Error('hello');
}, err => {
    console.log(err);
}).catch(err1 => {
    console.log(err1);
});

//此时只有then的第二个参数可以捕获到Promise内部抛出的错误信息
promise.then(res => {
    throw new Error('hello');
}, err => {
    console.log(err);
});


//此时catch可以捕获到Promise内部抛出的错误信息
promise.then(res => {
    throw new Error('hello');
}).catch(err1 => {
    console.log(err1);
});

两者之间的比较
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });

上述代码中，第二种写法要好于第一种写法，理由是第二个写法可以捕获签名then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。


.then里面的resolve报错，catch是可以捕获报错信息，then的第二个参数不能捕获
var pro=new Promise((resolve,reject)=>{
    resolve();
    reject();
})
pro.then(()=>{
    console.log('resolve1');
    var a = undefined;
    a.b();
    console.log('报错了的代码');
},(err)=>{console.log('reject1',err)}).catch((err)=>{
    console.log('catch1',err);
}).then(()=>{
    console.log('resolve2');
}).catch(()=>{
    console.log('catch2');
})
resolve1 
catch1 错误信息
resolve2
这里是在catch里面报错,resolve的回调执行报错可以被catch捕获到


Promise里面执行的代码可以被then的第二个参数捕获到,并且不会进入到resolve，而是直接进入reject

var pro=new Promise((resolve,reject)=>{
    var a = undefined;
    a.b();
    resolve();
    reject();
})
pro.then(()=>{
    console.log('resolve1');
    console.log('报错了的代码');
},(err)=>{console.log('reject1',err)}).catch((err)=>{
    console.log('catch1',err);
}).then(()=>{
    console.log('resolve2');
}).catch(()=>{
    console.log('catch2');
})
没有执行resolve代码，直接进入了reject
就算没有reject回调，还是会进入reject回调
如果不存在then的第二个回调，则会进入catch

如果catch的执行过程中报错，则进入之后相邻的catch

var pro=new Promise((resolve,reject)=>{
    var a = undefined;
    a.b();
    resolve();
    console.log('报错了的代码reject之前');
    reject();
    console.log('报错了的代码reject之后');
})
pro.then(()=>{
    console.log('resolve1');
    console.log('报错了的代码');
}).catch((err)=>{
    var a = undefined;
    a.b();
    console.log('catch1',err);
}).then(()=>{
    console.log('resolve2');
}).catch(()=>{
    console.log('catch2');
})
结果catch2
```

### js快速将字符串数组转化为数字数组（互换）

```js
1、数字数组转化为字符串数组
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String);  //结果： ['1', '2', '3', '4', '5', '6', '7', '8', '9']
	
2、字符串数组转化为数字数组
var a = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
a.map(Number);  //结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]
```



### CMD 查看端口号 根据PID 关闭进程

```
　　查询 8082 端口   :  netstat -ano | findstr "8082"

　　根据PID 杀死进程  :  taskkill /f /pid 12276
```

### css样式变为小手

```js
样式
cursor:pointer
```

### css超出字体隐藏

```
一行：
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
多行：
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;

uniapp text 标签w
```

### 字符串截取

```
1 取字符串的前i个字符
  str=str.substring(0,i);

2 去掉字符串的前i个字符
  str=str.substring(i); 

3 从右边开始取i个字符
  str=str.substring(str.length()-i); 
  str=str.substring(str.length()-i,str.length()); 

4 从右边开始去掉i个字符
  str=str.substring(0,str.Length-i);

5 从开始截取到中间某个指定字符  midChar (该字符出现的第一次)
  str=str.substring(0,str.indexOf(midChar));
   
6 从开始截取到指定某段字符串结尾  midStr
  str=str.substring(0,str.indexOf(midStr)+midStr.length());

7 如果字符串中有"abc"则替换成"ABC"
  str=str.replace("abc","ABC");
```

### jsp页面渲染表格

```js
1.首先确定表格所渲染的地方。新建表格容器，并隐藏。
		<table id="baseTable" border class="table">
                    <thead></thead>
                    <tbody></tbody>
        </table>
$('#baseTable').hide()
2.触发事件后显示表格,同时请求接口获取表格所需的数据
$('#baseTable').show()
$ajax
3.对表格进行渲染
（1）渲染thead头部
					var head="";
                    head+="<tr>";
                    head+="<th class='center'>统计提升</th>";
                    for(var i = 0;i<result.headerList.length;i++){
                        var l=result.headerList[i];
                        head+="<th class='center'>"+l.name+"</th>";
                    }
                    head+="</tr>";
                    $("#baseTable thead").append(head);
（2）渲染表格tbody，根据数据格式进行渲染每一条的数据，灵活运用
					var body1="";
                    body1+="<tr>";
                    body1+="<th class='center'>"+(parames.lastStartDate.substring(5)+'-'+parames.lastEndDate.substring(5))+"</th>";
                    for(var i = 0;i<result.firstList.length;i++){
                        var l=result.firstList[i];
                        body1+="<td class='center'>"+(l.total||'0')+'%'+"</td>";
                    }
                    body1+="</tr>";
                    $("#baseTable tbody").append(body1);
3.总结：
	可以通过字符串拼接或者是模板字符串进行表格的数据渲染。
```

### uni this.setdata报错

```js
重写setdata方法
			setData: function(obj) {
			      let that = this;
			      let keys = [];
			      let val, data;
			      Object.keys(obj).forEach(function(key) {
			        keys = key.split(".");
			        val = obj[key];
			        data = that.$data;
			        keys.forEach(function(key2, index) {
			          if (index + 1 == keys.length) {
			            that.$set(data, key2, val);
			          } else {
			            if (!data[key2]) {
			              that.$set(data, key2, {});
			            }
			          }
			          data = data[key2];
			        });
			      });
			    },
```

### js禁用右键事件

```js
    <script language="JavaScript">
        //禁止页面选择以及鼠标右键
        document.οncοntextmenu=function(){return false;}; 
        document.onselectstart=function(){return false;};
        let h = window.innerHeight;
        let w = window.innerWidth;
    
        //禁用右键
        document.oncontextmenu = function () { return false; };
    
        //在本网页的任何键盘敲击事件都是无效操作 （防止F12和shift+ctrl+i调起开发者工具）  
        window.onkeydown = window.onkeyup = window.onkeypress = function () {
            window.event.returnValue = false;
            return false;
        }
    
        //禁用开发者工具F12
        document.onkeydown = function () {
            if (window.event && window.event.keyCode == 123) {
                event.keyCode = 0;
                event.returnValue = false;
                return false;
            }
        };
    
        //如果用户在工具栏调起开发者工具，那么判断浏览器的可视高度和可视宽度是否有改变，如有改变则关闭本页面  
        window.onresize = function () {
            if (h != window.innerHeight || w != window.innerWidth) {
                window.close();
                window.location = "about:blank";
            }
        }
        </script>
```



### js监听多选/下拉

```js
select的监听： 
$(document).ready(function(){
        // alert('hehe');
        //alert();
        $('select#select').change(function(){
           //alert('hehehe'); 
           var checkvalue = $('#select').find("option:selected").val();
           
           alert(checkvalue);
        });
        
    });

单选框的监听（radio）
var val=$('input:radio[name="inline-radios"]:checked').val();

复选框的监听（checkbox）
$("#del_err").click(function(){
            //遍历所有选中的checkbox
            var a="";
            $('[name="err_checkbox"]:checked').each(
                function() {
                    a=a+"|"+$(this).val();
                }
            );
            alert(a);
          
       });
```

### jq监听多个相同元素类名

```js
 $(".obj").each(function(){  
        var num=$(this).index();  //index() 本元素的索引值  从0开始
        var that=$(this);
        that.click(function(){
                console.log(num);
                console.log(that.html());
        })
    })
```



### js更改对象的属性名

```js
const json = JSON.parse(JSON.stringify(options).replace(/name/g,"label"));

注：

1、options是需要更改属性的对象

2、replace(/name/g,"label")  ，将对象里所有属性为name的都修改成label
```

### 平方米

```
上标：
m 2 = m<sup>2</sup>
m 3 = m<sup>3</sup>

下标：
m 2 = m<sub>2</sub>
m 3 = m<sub>3</sub>
```

### 图片上传后如何清除图片样式

```
使用element-ui组件，用el-upload上传图片，上传图片后再次打开还是会有原来的图片，想要清空原来上传的图片，只需要在组件上绑定ref，在提交成功后的方法里调用this.$refs.upload.clearFiles();就可以清除原来上传的文件。
```

### vue修改元素样式问题

```js
通过给元素定义ref属性来进行选择操作
<view class="formaddUser u-flex" @click="addphone()" ref='addphonenone'></view>


addphone(){
				console.log(this.$refs.addphonenone)
				this.$refs.addphonenone.$el.style.display='none'
			}
通过this.$refs.属性.$el.style.样式=''
```

### uniapp数组数据改变后如何触发视图更新

```
在数组更新后添加
this.$forceUpdate()
```

### uniapp如何去除导航栏

```
1.在app.json里找到需要取消导航的页面
2.在style里写入
“app-plus”:{
“titleNView”:false
}
```



### uniapp导航栏添加右侧字体并自定义事件

```js
"pages": [{
					"path": "pages/companylist/companylist",
					"style": {
						"navigationBarTitleText": "渠道公司",
						"enablePullDownRefresh": false,
						"app-plus": {
							"titleNView": {
								"buttons": [{ 
									"color": "#ffffff",
									"fontSize": "30rpx",
									"text": "筛选"
								}]
							}


						}
					}
				}
页面中

onNavigationBarButtonTap(e){
}
```

### uniapp下载文件

```
//#ifndef APP-PLUS
			window.location.href=url
			//#endif
			
			//#ifdef APP-PLUS
				uni.downloadFile({
					url,
					success:({statusCode,tempFilePath})=>{
						//statusCode状态为200表示请求成功，tempFIlePath临时路径
						if(statusCode==200){
							// 保存到本地
							uni.saveFile({
								tempFilePath,
								success: (res) => {
									 //res.savedFilePath文件的保存路径
									//保存成功并打开文件
									uni.openDocument({
										filePath:res.savedFilePath,
										success: (res) => {
											console.log('成功打开文档')
										}
									})
								},
								fail: () => {
									console.log('下载失败')
								}
							})
						}
					}
				})
			//#endif
```

### uniapp图片转base64格式

```
方法一：
uni.chooseImage({
    count: 6, //默认9
    sizeType: ['original', 'compressed'], //可以指定是原图还是压缩图，默认二者都有
    sourceType: ['album'], //从相册选择
    success: function (res) {
        this.urlTobase64(res.tempFilePaths[0])
    }
});
 
urlTobase64(url){
    uni.request({
	url: url,
	method:'GET',
	responseType: 'arraybuffer',
	success: res => {
		let base64 = uni.arrayBufferToBase64(res.data); //把arraybuffer转成base64 
		base64 = 'data:image/jpeg;base64,' + base64 //不加上这串字符，在页面无法显示
		console.log(base64)
	}
    })
}
方法二：

uni.getFileSystemManager().readFile({
    filePath: item, //选择图片返回的相对路径
    encoding: 'base64', //编码格式
    success: res => { //成功的回调
        let base64 = 'data:image/jpeg;base64,' + res.data //不加上这串字符，在页面无法显示的
        that.dataList.picList.push(base64);
    }
})
```

### Object.defineProperty()

```js
Object.defineProperty() 方法会直接在一个对象上面定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
语法：
Object.defineProperty(obj, prop, descriptor)
参数：
obj：要定义属性的对象。
prop：要定义或修改的属性的名称或Symbol
descriptor:要定义或修改的属性描述符。
返回值
被传递给函数的对象。

在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。

描述：
该方法允许精确地添加或修改对象的属性。通过复制操作添加的普通属性是可以枚举的，在枚举对象属性时会被枚举到(for…in或者Object.keys方法)可以改变这些属性的值，也可以删除这些属性，这个方法允许修改默认的额外选项或配置。默认情况下，使用Object.defineProperty()添加的属性值是不可修改的。

对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是有getter函数和setter函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。

这两种描述符都是对象。他们共享以下可选键值（默认值是在使用Object.definProperty()定义属性时的默认值）

configurable
当且仅当该属性的configurable键值为true时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为false

enumerable
当且仅当该属性的enumerable键值为true时，该属性才会出现在对象的枚举属性中。默认为false

数据描述符还具有以下可选键值：

value
	该属性对应的值。可以是任何有效的JavaScript值（数值，对象，函数等）。
    默认为undefined。
writable
	当且仅当该属性的writable键值为true时，属性的值，也就是上面的value才能被赋值运算符改变。默认为false。
    存取描述符还具有以下可选键值：
    get
    	属性的getter函数，如果没有getter,则为underfined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为undefined。
	set
    	属性的setter函数，如果没有setter则为，undefined。当属性被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的this对象。
        
```



###  element数组里面的值改变了但是表格未更新

因为采用了多重嵌套渲染所以视图并未实施更新

```js
1.使用$set对数据进行赋值和更新（未成功）
this.$set(this.allGearList[this.idx][this.choicId],'num',this.checkedCities1.length)
数据成功更新但是视图并未渲染，推测是由于数据过于深入造成
2.使用 JSON.parse(JSON.stringify(this.tables)) 也可行还可以对每一项进行重新赋值，过于麻烦this.tables = this.tables.filter(item => item); ，把每一项重新 复赋值给 this.tales ；（未尝试。百度得出）
3.直接使用es6的 Object.assign复制一个新的对象 this.tables = Object.assign([],this.tables) 少去了过滤循环的麻烦 简单明了（成功）
```

### element 中 input设置了type=“number“还能输入e和负数的问题如何解决？

```
<el-input v-model="name" onkeypress="return (/[\d]/.test(String.fromCharCode(event.keyCode)));"/>
onkeypress 事件会在键盘按键被按下并释放一个键时发生。
fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。

<el-input
	v-model="form.test"
	oninput="value=value.replace(/[^0-9.]/g,'').replace(/^\./g, '').replace('.', 'dollar#dollar').replace(/\./g, '').replace('dollar#dollar', '.');"
	size="mini"/>

```



### js小数运算会出现的精度缺失问题

```js
1.限制精确位数
限制保留几位小数的方法来避免误差：
// 保留两位小数
const num = (0.1 + 0.2).toFixed(2);

2.先讲小数转化为整数，运算之后再重新转化为小数
限制保留小数位的方式不一定适用于所有场景，有时候必须要根据不同的小数位进行计算。

需要定义一个方法，用来对小数进行加法运算。
/**
    * 用来进行小数相加的工具方法
    * @param {*} num1 
    * @param {*} num2 
    */
addNum (num1, num2) {
    let sq1, sq2, multiple;
    try {
        sq1 = num1.toString().split(".")[1].length;
    }
    catch (e) {
        sq1 = 0;
    }
    try {
        sq2 = num2.toString().split(".")[1].length;
    }
    catch (e) {
        sq2 = 0;
    }
    multiple = Math.pow(10, Math.max(sq1, sq2) + 1);
    return (num1 * multiple + num2 * multiple) / multiple;
}

```

### js数组的方法reduce

```js
1.语法
arr.reduce(callback,[initialValue])

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用reduce的数组

callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）

解析：
var arr = [1, 2, 3, 4];
var sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
})
console.log(arr, sum);
打印结果：
1 2 1
3 3 2
6 4 3
[1, 2, 3, 4] 10

这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。

第二个例子：
var  arr = [1, 2, 3, 4];
var sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
}，0) //注意这里设置了初始值
console.log(arr, sum);

打印结果：
0 1 0
1 2 1
3 3 2
6 4 3
[1, 2, 3, 4] 10

这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。

结论：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。

注意，后面数组要有初始值。


```

https://www.jianshu.com/p/e375ba1cfc47

### 电话号隐式显示

```
phone = res.phone.substr(0, 3) + '****' + res.phone.substr(7)


正则（尚未验证）
var reg = getRegExp('^(\d{3})\d{4}(\d{4})$')
return item.replace(reg, "$1****$2")
```

#### vue导出文件

```js
import axios from 'axios'
// 导出Excel公用方法
export function exportMethod(data) {
    axios({
        method: data.method,
        url: `${data.url}${data.params ? '?' + data.params : ''}`,
        responseType: 'blob',
        headers:{
            'Content-Type': 'application/json'
        }
    }).then((res) => {
        // console.log('明细导出')
        const link = document.createElement('a')
        let blob = new Blob([res.data], {type: 'application/vnd.ms-excel'})
        link.style.display = 'none'
        link.href = URL.createObjectURL(blob)

        // link.download = res.headers['content-disposition'] //下载后文件名
        link.download = data.fileName //下载的文件名
        document.body.appendChild(link)
        link.click()
        document.body.removeChild(link)
    }).catch(error => {
       // Message.error({
       //     message: '网络连接错误'
       //  })
        console.log(error)
    })
}


//导出
            exportExcel(){
                let myObj={
                    method: 'get',
                    url: '/order/exportExcel',
                    fileName:'订单',
                    params:`merchantId=${this.search.merchantId}&beginDate=${this.dates[0]}&endDate=${this.dates[1]}`
                }
                exportMethod(myObj);
            },
                

 
```

### 导出文件在修改

```js
// 导出Excel公用方法
     exportMethod(url,name,params={}) {
      axios({
          method: 'get',
          url:baseUrl+'/'+url,
          params,
          responseType: 'blob',
          headers:{
              'Content-Type': 'application/json'
          }
      }).then((res) => {
          // console.log('明细导出')
          const link = document.createElement('a')
          let blob = new Blob([res.data], {type: 'application/vnd.ms-excel'})
          link.style.display = 'none'
          link.href = URL.createObjectURL(blob)

          // link.download = res.headers['content-disposition'] //下载后文件名
          let date=new Date()
          let time=date.toLocaleDateString()
          console.log(time,'时间');
          link.download = (name||'导出文件')+time//下载的文件名
          document.body.appendChild(link)
          link.click()
          document.body.removeChild(link)
      }).catch(error => {
         // Message.error({
         //     message: '网络连接错误'
         //  })
          console.log(error)
      })
      },
                          
 由于存在ie浏览器兼容问题所以做以下修改
 ie不兼容的原因是：
         // 导出.Excel公用方法
        exportMethod(url, name, params = {}) {
            axios({
                method: 'get',
                url: baseUrl + '/' + url,
                params,
                responseType: 'blob',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then((res) => {
                // console.log('明细导出')
                let blob = new Blob([res.data], { type: 'application/vnd.ms-excel' })
                let date = new Date()
                let time = date.toLocaleDateString()
                console.log(time, '时间');

                if ('download' in document.createElement('a')) {
                    const link = document.createElement('a')

                    link.style.display = 'none'
                    link.href = URL.createObjectURL(blob)

                    // link.download = res.headers['content-disposition'] //下载后文件名
                    link.download = (name || '导出文件') + time //下载的文件名
                    document.body.appendChild(link)
                    link.click()
                    document.body.removeChild(link)
                } else {
                    // console.log("--------------------jingla")
                    let fileName = (name || '导出文件') + time + '.xls' //下载的文件名
                    navigator.msSaveBlob(blob, fileName)
                }

            }).catch(error => {
                // Message.error({
                //     message: '网络连接错误'
                //  })
                console.log(error)
            })
        },
            
或者
var obj = {
        cusPerformanceSettlementId: this.id,
      };
      //   window.open("performanceSettlement/out");

      //   this.$api.video.exportCompanyList(obj).then((res) => {
      //     console.log(res);
      //   });
      let current = new Date();
      let today =
        current.getFullYear() +
        (current.getMonth() + 1).toString().padStart(2, "0") +
        current.getDate().toString().padStart(2, "0");
      this.$api.video.exportCompanyList(obj).then((res) => {
        let blob = new Blob([res], { type: "chunked" });
        let downloadLink = document.createElement("a");
        const URL = window.URL || window.webkitURL || window.moxURL;
        let downUrl = URL.createObjectURL(blob);
        downloadLink.href = downUrl;
        downloadLink.download = today + ".xls";
        downloadLink.click();
        window.URL.revokeObjectURL(downUrl);
      });
```

### vue项目关于ie浏览器不兼容问题

```js
vue项目下IE浏览器打开报错：[vuex] vuex requires a Promise polyfill in this browser

原来是因为语法兼容问题，IE不支持ES6语法，babel-polyfill可以模拟ES6使用的环境，可以使用ES6的所有新方法。

第一步：安装babel-polyfill
npm i babel-polyfill -S
因为polyfill 要在编译你的代码之前执行，所以安装到dependency（生产环境）而不是devDependency（开发环境）

第二步：在build/webpack.base.conf.js配置文件中的entry项
module.exports = {
　　app: ['babel-polyfill','./src/main.js']
};
注意数组里面的顺序不能改变，改变则无用
```

### 宏任务和微任务

```
在任务队列中，分为宏任务队列和微任务队列，对应的里面存放的就是微任务和宏任务。
宏任务和微任务都是异步任务

区别：两者的区别就是执行顺序的区别。

在同步任务中，任务的执行都是按照代码的顺序执行的，而异步任务的执行而是需要按顺序的，队列的属性就是先进先出，因此异步任务会按照进入队列的顺序依次执行。

但在某种场景下,如果只按照进入队列的顺序依次执行的话，会出问题，比如定时器。因此浏览器会将异步任务分为宏任务和微任务。

任务入列：
任务进入任务队列，其实会利用到浏览器的其他线程。虽然说JavaScript是单线程语言，但是浏览器不是单线程的。不同的线程就会对不同的事件进行处理，但对于事件可以执行的时候，对于线程就会将其放入任务队列。
	js引擎线程：用于解释执行js代码，用户输入，网络请求等；
	GUI渲染线程：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；
	http异步网络请求线程：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；
	定时触发器线程：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中
	浏览器事件处理线程：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。
```

#### 宏任务

|                       | 浏览器 | Node |
| :-------------------- | :----- | :--- |
| 整体代码(script)      | ✅      | ✅    |
| UI交互事件            | ✅      | ❌    |
| I/O                   | ✅      | ✅    |
| setTimeout            | ✅      | ✅    |
| setInterval           | ✅      | ✅    |
| setImmediate          | ❌      | ✅    |
| requestAnimationFrame | ✅      | ❌    |

#### 微任务

| process.nextTick           | ❌    | ✅    |
| -------------------------- | ---- | ---- |
| MutationObserver           | ✅    | ❌    |
| Promise.then catch finally | ✅    | ✅    |

# 事件循环 Event Loop

其实宏任务队列和微任务队列的执行，就是事件循环的一部分了，所以放在这里一起说。

事件循环的具体流程如下：

1. 从宏任务队列中，按照**入队顺序**，找到第一个执行的宏任务，放入调用栈，开始执行；
2. 执行完**该宏任务**下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，**直至微任务队列清空为止**；
3. 当微任务队列清空后，一个事件循环结束；
4. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

这里有几个重点：

- 当我们第一次执行的时候，解释器会将整体代码`script`放入宏任务队列中，因此事件循环是从第一个宏任务开始的；
- 如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。



### js的?.以及??用法 (可选链操作符)

```js
第一个：问号点 （?.）	
const obj = {
		hh:"xxx"
	}
	let res = obj?.data?.list

    <=等价=> let res = obj && obj.data && obj.data.list
    
    作用就是判断这个对象（this.element）下的（businessObject）下的（value）下的（length）是否为null或者undefined，当其中一链为null或者undefined时就返回undefined，这样即使中间缺少一个属性也不会报错，双问号后面接的就是默认值。

第二个：问号问号 （?？）
    console.log(1 || "xx") 			//1
console.log(0 || "xx") 			//xx
console.log(null || "xx")		//xx
console.log(undefined || "xx")  //xx
console.log(-1 || "xx") 		//-1
console.log("" || "xx") 		//xx

console.log(1 ?? "xx")			//1
console.log(0 ?? "xx") 			//0
console.log(null ?? "xx") 		//xx
console.log(undefined ?? "xx")  //xx
console.log(-1 ?? "xx") 		//-1
console.log("" ?? "xx") 		//''

？的意思是当左边的值为null或undefined的时候 就取??右边的值 。 

var obj ={}
console.log(obj?.a?.b ?? 233 ) //233
var obj={a:{b:1}}
console.log(obj?.a?.b??233) //1
```





### vue修改ele的样式穿透问题

```js
在使用vue构建项目的时候，引用了第三方组件库，只需要在当前页面修改第三方组件库的样式以做到不污染全局样式。通过在样式标签上使用scoped达到样式只制作用到本页面，但是此时再修改组件样式不起作用。


vue中的scoped属性的效果主要通过PostCSS转译实现 将样式代码转译为如下格式
.example[data-v-5558831a] {
  color: red;
}

通过 >>> 穿透scoped
 iview中需要在组件上使用i-class声明第三方组件类名
<style scoped>
    外层 >>> 第三方组件类名{
        样式
    }
</style>
有些Sass 、Less之类的预处理器无法正确解析 >>>。可以使用 /deep/操作符( >>> 的别名)
<style lang="sass" scoped>
/deep/  第三方组件类名 {
      样式
  }

</style>

注意：
        穿透方法实际上违反了scoped属性的意义。而且在vue中过多使用scoped导致页面打包文件体积增大。通常能写在index中的样式尽量写在index中，我们可以通过在index样式中通过外层组件添加唯一class来区分组件+第三方样式来实现实现了类似于scoped的效果，又方便修改各种第三方组件的样式。

```

### PostCSS 

```
1. 它本质上是一个什么东西
PostCSS 可以直观的理解为：它就是一个平台
为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大。
PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）
```

可以理解为下面这个模型。

![图片描述](https://segmentfault.com/img/bVqy8j)

```js
大致步骤：
将CSS解析成抽象语法树(AST树)
将AST树”传递”给任意数量的插件处理
将处理完毕的AST树重新转换成字符串
在PostCSS中有几个关键的处理机制：
Source string → Tokenizer → Parser → AST → Processor → Stringifier:将源css字符串进行分词

2. 它能解决我们什么问题？它是通过什么方式来解决我们的问题？

它能够为 CSS 提供额外的功能；

通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer

我们能够使用JavaScript来开发插件（这点对前端来说很重要）

3. 它解决我们的问题是为什么？优势何在？
比如，我们用 SASS 来处理 box-shadow 的前缀，我们需要这样写：
/* CSS3 box-shadow */
@mixin box-shadow($top, $left, $blur, $size, $color, $inset: false) {
    @if $inset {
        -webkit-box-shadow: inset $top $left $blur $size $color;
        box-shadow: inset $top $left $blur $size $color;
    } @else {
        -webkit-box-shadow: $top $left $blur $size $color;
        box-shadow: $top $left $blur $size $color;
    }
}

使用 PostCSS 我们只需要按标准的 CSS 来写就行了，因为最后 autoprefixer 会帮我们做添加这个事情
box-shadow: 0 0 3px 5px rgba(222, 222, 222, .3);

所以，这里就出现了一个经常大家说的未来编码的问题。实际上，PostCSS 改变的是一种开发模式。

SASS等工具：源代码 -> 生产环境 CSS

PostCSS：源代码 -> 标准 CSS -> 生产环境 CSS

4. 怎么实现与 SASS、LESS、Stylus 相同的功能
这里列几个便于理解的插件
postcss-each
postcss-for
postcss-mixins
postcss-extend
5. 它由哪些东西组成？
其实从官方介绍来看，只包含以下内容：
CSS Parser
CSS 节点树 API
source map 生成器
生成节点树串
其中的 I/O 体现在什么地方？主要体现在：
Input: 插件程式和CSS Parser
Output: 生成节点树串
```

### 获取数组某项最大值，处理数据

```js
			// 定义一个公共方法对数据进行处理
			dealData(arr){
				// 获取最大值
				let num=Math.max.apply(Math, arr.map(function (o) { return o.zxl })) //结果：3
				// console.log(num)
				if(num>100){
					// 获取最大值的下标
					// let idx=arr.findIndex(item=>item.zxl==num)
					// console.log(idx,123)
					arr.map(item=>{
						item.zxl1=Math.floor(item.zxl/num*100)
					})
					// console.log(arr)
					return arr
				}else{
					arr.map(item=>{
						item.zxl1=item.zxl
					})
					return arr
				}
			},
```



#### 复制文本内容

```js
let str=`123`
            console.log(str);
            let input=document.createElement('input');
			//如果需要复制格式例如换行需要使用 textarea 即
			let input=document.createElement('textarea');
            input.value=str
            document.body.appendChild(input)
            input.select()
            document.execCommand('Copy');
            this.$message.success('复制成功')
            input.remove()
```

#### vue注册一个全局的方法

````js
方法一：
在util里面新建一个js文件，命名为minxin
文件内容如下
import api from '../http/api'
const mixin={
  methods: {
    /* 字典表查询

    */
   getmsg(type,msg){
     api.log.getAllmsg({
      type
     })
     .then(res=>{
       if(res.code==10000){
        this[msg]=res.data
       }
     })
   }
  },
}
export default mixin
同时在main.js注册组件

import mixin from './utils/minxin'
Vue.mixin(mixin)
就可以直接进行使用方法函数了

方法二：
挂载到Vue的prototype上。把全局方法写到一个文件里面，然后for循环挂载到Vue的prototype上，缺点是调用这个方法的时候没有提示

 Object.keys(tools).forEach(key => {
      Vue.prototype[key] = tools[key]
 })
````

### minxins

```
混入（minxins）
提供了一直非常灵活的方式，来分发vue组件中的可复用功能。一个混入对象可以包含任意组件选项，当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项

选项合并
当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行合并。比如，数据对象在内部会进行递归合并，并在放生冲突时以组件数据优先。
同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
值为对象的选项，例如methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。
注意:Vue.extend() 也使用同样的策略进行合并。

全局混入

混入也可以进行全局注册，使用时格外小心，一旦使用全局混入，他经影响每一个之后创建的Vue实例，使用恰当时，这可以用来为自定义选项注入处理逻辑
请谨慎使用群居混入，因为他会影响每个单独创建的vue实例，包括第三方组件。大多数情况下，只应当应用于自定义选项，推荐作为插件发布，避免重复应用混入。

自定义选项合并策略

自定义选项将使用默认策略，即简单的覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向Vue.config.optionMergeStrategies添加一个函数
同时可以使用与methods相同的合并策略。
```

vue官方介绍网址https://cn.vuejs.org/v2/guide/mixins.html

#### mixins和vuex区别

```js
mixins：可以定义公用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。
如果相同对象，组件会覆盖mixins
中文意思为混入，所以他的功能是混合，对象和引入mixins的组件混合

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改次变量的值之后，其他组件中次变量的值也会随之改变


```

#### mixins和组件的区别

```
区别
组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相互独立的
mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于拓展了父组件的对象与方法。可以理解为形成了一个新的组件。（装饰器模式）
```

#### 遍历数组把相同的指定项放到一个数组内

```
                    let list=[]
                    let obj={}
                    for(let i=0;i<arr.length;i++){
                      let item=arr[i]
                      if(!obj[item.pid]){
                        list.push({
                          pid:item.pid,
                          list:[item]
                        })
                        obj[item.pid]=item
                      }else{
                        for(let i=0;i<list.length;i++){
                          let item1=list[i]
                          if(item1.pid==item.pid){
                            item1.list.push(item);
                            break;
                          }
                        }
                      }
                    }
                    console.log(list,'数组');
```

### vue bus

```js
解决问题：解决兄弟组件之间的通信问题。
先进行下载
npm i vue-bus
先进行注册
import VueBus from 'vue-bus';
Vue.use(VueBUS)
使用：
兄弟组件一发送数据：
this.$bus.emit('方法名',数据)

export default {
  data () {
    return {}
  },
  methods: {
    clickEve () {
      bus.$emit('getMessage', 'qqqq')
    }
  }
}

接收数据兄弟组件:
通过this.bus.on来进行监听
一般在created()里面来使用

 methods:{
    showMsg (msg) {　
　　　　console.log('msg', msg)
　　}
  },
  created () {
    bus.$on('getMessage', this.showMsg ) //对事件进行监听
  },
  beforDestory () {
　　this.$off('getMessage', this.showMsg)//x
  }

```

### for of 和for in 的区别

```
for in :
一般用于遍历对象的可枚举属性，以及对象从构造函数原型中继承的属性。对于每一个不同的属性，语句都会被执行。
不建议使用for in 遍历数组，因为输出的顺序是不固定的
如果迭代的对象的变量值是null或者undefined，for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是null或者underfined


for of :
for of语句在可迭代对象（包括 Array,Map,Set,String,TypedArray,arguments对象等到）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值的执行语句。
```

### vue的Diff算法

```js
本质：diff算法的本质是找出对象之间的差异，目的是尽可能复用节点

发生的时机
在数据更新的时候发生diff，因为数据更新会运行render函数得到的虚拟dom树，最后页面重新渲染。
当组件创建的时候，组件所依赖的属性或者数据变化时，会运行一个函数，该函数会做两件事。
运行_render生成一颗新的虚拟dom树(vnode tree)
运行_updata，传入_render生成新的虚拟dom树的根节点，对两棵树进行对比，最后完成对真实dom的更新

_update函数职能：
_update函数会接收到一个vonde参数，这就是新生成的虚拟dom树，同时，_update函数通过当前组件的_vnode属性，拿到旧的虚拟dom树。_update函数首先会给组件的_vnode属性重新赋值，让它指向新树
对比oldVnode和vnode就行了，对比的目的就是更新真实dom
判断旧树oldVnode是否存在：

不存在：说明这是第一次加载组件，于是通过内部的patch函数，直接遍历新树，为每个节点生成真实DOM，然后挂载到每个节点的elm属性上

存在：说明之前已经渲染过该组件，于是通过内部的patch函数，对新旧两棵树进行对比，从而达到下面两个目标：
完成对所有真实dom的最小化处理
让新树的节点对应合适的真实dom

patch函数

patch函数首先对根节点进行对比
如果两个节点：

相同，进入 更新 流程
将旧节点的真实dom赋值到新节点：newVnode.elm = oldVnode.elem，旧节点会被垃圾回收机制回收
对比新节点和旧节点的属性，有变化的更新到真实dom中
当前新旧两个节点处理完成，开始 「对比子节点」

不相同
新节点递归， 「新建元素」
旧节点 「销毁元素」
对比子节点
虚拟dom树已经完成，就剩修改真实dom了，但是修改真实dom的效率是比较耗时的，vue的原则是能不改就不改，尽量啥也别做，在「对比子节点」时，vue一切的出发点，都是为了：
尽量啥也别做
不行的话，尽量仅改动元素属性
还不行的话，尽量移动元素，而不是删除和创建元素
实在不行的话，删除和创建元素


总结
当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom
对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程
在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较
在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的
具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。
在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。
这样一直递归的遍历下去，直到整棵树完成对比。
```

### html换行

```
word-wrap:break-word; 
word-break:break-all; 
overflow: hidden;   
```

### js动态添加元素点击事件失效问题

```js
这种方法
$(document).on('click', '.sw-off', function(){
    $(this).toggleClass('sw-on');
});
```

###  数组扁平化

```js
数组扁平化，就是将一个嵌套多层的数组array（嵌套可以使任何层数)转换为只有一层的数组。

例如: arr=[1,[2,[3,4]]]
变为[1,2,3,4]
解决办法：
一：递归
通过循环遍历最外层的每一个元素，看看是否为数组，如果是继续递归执行，不是的话，放到最后的结果里面

function flattern(arr) {
        let result = [];
        for(let i = 0; i < arr.length; i++) {
            if(Array.isArray(arr[i])) {
                flattern(arr[i])
            } else {
                result.push(arr[i])
            }
        }
        return result;
    }

二：toString
toString()方法返回一个表示该对象的字符串  --MDN

这是mdn官方文档对这个方法的解释，同时用到了拆箱操作。在JavaScript标准中，规定了ToPrimitive函数，他是对象类型到基本类型的转换（拆箱转换）

对象到String和Number的转换都遵循先拆箱在转换的规则。通过拆箱转换，吧对象变成基本类型，再从基本类型转换为对应的String或者Nmber

拆箱转换会尝试调用valueOf和toString来获得拆箱后的基本类型.如果valueOf和ToSting都不存在，或者没有返回基本类型，则会产生类型错误TypeError

嵌套数组调用方法后，直接是扁平化后的字符串，然后在调用split方法转换为数组即可


function flatten(arr) {
    return arr.toString().split(',').map(function(item){
        return +item //+可以快速获得Number类型
    })
}

我们也可以通过toString()来获取每个对象的类型，为了每个对象都能通过Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg



let toString = Object.prototype.toString;
 
toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]
 
//Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]

三 reduce
数组的方法reduce可以实现


function flatten(arr) {
    return arr.reduce(function(prev, next){
        return prev.concat(Array.isArray(next) ? flatten(next) : next)
    }, [])
}

四 扩展运算符 ...
ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，所以也可以递归扁平化数组，代码如下：

function flatten(arr) {
 
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }  //ES6新方法
 
    return arr;
}

五 undercore


/**
 * 数组扁平化
 * @param  {Array} input   要处理的数组
 * @param  {boolean} shallow 是否只扁平一层
 * @param  {boolean} strict  是否严格处理元素，下面有解释
 * @param  {Array} output  这是为了方便递归而传递的参数
 * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528
 */
function flatten(input, shallow, strict, output) {
 
    // 递归使用的时候会用到output
    output = output || [];
    var idx = output.length;
 
    for (var i = 0, len = input.length; i < len; i++) {
 
        var value = input[i];
        // 如果是数组，就进行处理
        if (Array.isArray(value)) {
            // 如果是只扁平一层，遍历该数组，依此填入 output
            if (shallow) {
                var j = 0, len = value.length;
                while (j < len) output[idx++] = value[j++];
            }
            // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output
            else {
                flatten(value, shallow, strict, output);
                idx = output.length;
            }
        }
        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output
        else if (!strict){
            output[idx++] = value;
        }
    }
 
    return output;
 
}
```



### 获取时间格式

```js
var date = new Date();

date .getYear(); //获取当前年份(2位)

date .getFullYear(); //获取完整的年份(4位)

date .getMonth(); //获取当前月份(0-11,0代表1月)

date .getDate(); //获取当前日(1-31)

date .getDay(); //获取当前星期X(0-6,0代表星期天)

date .getTime(); //获取当前时间(从1970.1.1开始的毫秒数)

date .getHours(); //获取当前小时数(0-23)

date .getMinutes(); //获取当前分钟数(0-59)

date .getSeconds(); //获取当前秒数(0-59)

date .getMilliseconds(); //获取当前毫秒数(0-999)

date .toLocaleDateString(); //获取当前日期

var mytime=date .toLocaleTimeString(); //获取当前时间

date .toLocaleString( ); //获取日期与时间

1.将日期格式转化为时间戳：
var date = new Date('2020-03-05 09:00:00');
// 有三种方式获取
var time1 = date.getTime();

var time2 = date.valueOf();

var time3 = Date.parse(date);

console.log(time1);//1583370000000

console.log(time2);//1583370000000

console.log(time3);//1583370000000
注：在苹果手机里这样使用会因为日期中间有空格导致结果为NaN,可以将日期分割然后进行转化
var str='2018-06-08 18:00:00' ;

var time=new Date(str.split(" ")).getTime();

2.将时间戳转化为日期格式：
function timestampToTime(timestamp) {
	var  date = new Date(timestamp);//时间戳为10位需*1000，时间戳为13位的话不需乘1000
        // var  date = new Date(timestamp * 1000);//时间戳为10位需*1000，时间戳为13位的话不需乘1000

	var yyyy = date.getFullYear() + '-';

	var MM = (date.getMonth()+1 < 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-';

         // var dd = date.getDate() + ' ';
	var dd = (date.getDate() < 10 ? '0'+(date.getDate()) : date.getDate()) + ' ';

         // var HH = date.getHours() + ':';
	var HH = (date.getHours() < 10 ? '0'+(date.getHours()) : date.getHours()) + ':';

         // var mm = date.getMinutes() + ':';
	var mm = (date.getMinutes() < 10 ? '0'+(date.getMinutes()) : date.getMinutes()) + ':';

         // var ss = date.getSeconds();
	var ss = (date.getSeconds() < 10 ? '0'+(date.getSeconds()) : date.getSeconds());

	return yyyy+MM+dd+HH+mm+ss;
}

timestampToTime(1583370000000);

console.log(timestampToTime(1583370000000));  // 2020-03-05 09:00:00


JS获取当前时间戳方法

第一种方法：(这种方法只精确到秒)
var timestamp = Date.parse(new Date());
第二种方法：
var timestamp = (new Date()).valueOf();
第三种方法：
var timestamp=new Date().getTime()；
第一种：获取的时间戳是把毫秒改成000显示，因为这种方式只精确到秒
第二种和第三种是获取了当前毫秒的时间戳
```

### 获取前七天数据

```
GetTime() 
			 {
				var date = new Date();
				var base = Date.parse(date); // 转换为时间戳
				var year = date.getFullYear(); //获取当前年份
				var mon = date.getMonth() + 1; //获取当前月份
				var day = date.getDate(); //获取当前日
				var oneDay = 24 * 3600 *1000
				//var daytime = `${year}${mon >= 10 ? mon : '0' + mon}${day >= 10 ? day : '0' + day}`; //今日时间
				//this.$data.daytime = daytime; // 今日时间赋值给变量
				
				var daytimeArr = []
				for (var i = 1; i < 7 ; i++) { //前七天的时间
					var now = new Date(base -= oneDay);
					var myear = now.getFullYear();
					var month = now.getMonth() + 1;
					var mday = now.getDate()
					daytimeArr.push([myear, month >=10 ?month :'0'+ month, mday>=10?mday:'0'+mday].join('-'))
				}
				return daytimeArr
			}
```



### localStorage设置过期时间

```
浏览器需要存储一个用户标识和cookie一样需要过期时间，但是用的是localStorage存储。但是localStorage一经存储除非删除是不会过期的。那就需要自己实现过期机制

方法一：ES5扩展Storage
思路：存储的值加一个时间戳，下次取值是验证时间戳
注意：localStorage只能存储字符，存入时将对象转为json字符串,读取时也要解析

Storage.prototype.setExpire = (key, value, expire) => {
	let obj = {
	data: value,
	time: Date.now(),
	expire: expire
	};
	//localStorage 设置的值不能为对象,转为json字符串
	localStorage.setItem(key, JSON.stringify(obj));
}

Storage.prototype.getExpire = key => {
    let val = localStorage.getItem(key);
    if (!val) {
        return val;
    }
    val = JSON.parse(val);
    if (Date.now() - val.time > val.expire) {
        localStorage.removeItem(key);
        return null;
    }
    return val.data;
}
方法二：ES6扩展Storage

其中set(),get(),remove()方法可以理解用来存、取、删, initRun()做什么用呢？过期的值只有取时才能知道是不是过期，不取一直存着。initRun()和constructor只是在初始化时实现清理，也不是一定即时。另外写一个定时器去清理貌似也不值当，所以觉得做到这样已经够用了。

class Storage {

    constructor(props) {
        this.props = props || {}
        this.source = this.props.source || window.localStorage
        this.initRun();
    }
    initRun(){
        /*
        * set 存储方法
        * @ param {String}     key 键
        * @ param {String}     value 值，存储的值可能是数组/对象，不能直接存储，需要转换 JSON.stringify
        * @ param {String}     expired 过期时间，以分钟为单位
        */
        const reg = new RegExp("__expires__");
        let data = this.source;
        let list = Object.keys(data);
        if(list.length > 0){
            list.map((key,v)=>{
                if( !reg.test(key )){
                    let now = Date.now();
                    let expires = data[`${key}__expires__`]||Date.now+1;
                    if (now >= expires ) {
                        this.remove(key);
                    };
                };
                return key;
            });
        };
    }

	set(key, value, expired) {
	    /*
	    * set 存储方法
	    * @ param {String}     key 键
	    * @ param {String}     value 值，
	    * @ param {String}     expired 过期时间，以毫秒为单位，非必须
	    */
	    let source = this.source;
	    source[key] = JSON.stringify(value);
	    if (expired){
	        source[`${key}__expires__`] = Date.now() + expired
	    };
	    return value;
	}

    get(key) {
        /*
        * get 获取方法
        * @ param {String}     key 键
        * @ param {String}     expired 存储时为非必须字段，所以有可能取不到，默认为 Date.now+1
        */
        const source = this.source,
        expired = source[`${key}__expires__`]||Date.now+1;
        const now = Date.now();
    
        if ( now >= expired ) {
            this.remove(key);
            return;
        }
        const value = source[key] ? JSON.parse(source[key]) : source[key];
        return value;
	}

	remove(key) {
	    const data = this.source,
	        value = data[key];
	    delete data[key];
	    delete data[`${key}__expires__`];
	    return value;
	}

}

```

https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html

### forEach()和map()的区别

```
相同点：
都是循环遍历数组中的每一项
forEach和map方法里每次执行匿名函数都支持三个参数，参数分别是item，index,arr（原数组）
匿名函数中的this斗志指向window
只能遍历数组

区别：
forEach()没有返回值
map()有返回值，可以return 出来
```

### router-view父子组件传参

```
和正常的子父组件传值一样

父组件传递
<router-view  :projectId="projectId"></router-view>
子组件接收
props:['projectId'],

父子组件传值

this.$emit('updateProjectId','xxxxxx')
<router-view class="systemContent" @updateProjectId="updateProjectIdParent"></router-view>

updateProjectIdParent(msg){
    this.selectArr.push(msg)
},
```

### axios 发生请求

```
axios.request(config)

//原始的Axios请求方式
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  },
  timeout: 1000,
  ...//其他相关配置
});

axios.get(url[, config])

axios.get('demo/url', {
    params: {
        id: 123,
        name: 'Henry',
    },
   timeout: 1000,
  ...//其他相关配置
})

axios.delete(url[, config])

//如果服务端将参数作为java对象来封装接受
axios.delete('demo/url', {
    data: {
        id: 123,
        name: 'Henry',
    },
     timeout: 1000,
    ...//其他相关配置
})
//如果服务端将参数作为url参数来接受，则请求的url为:www.demo/url?a=1&b=2形式
axios.delete('demo/url', {
    params: {
        id: 123,
        name: 'Henry',
    },
     timeout: 1000,
    ...//其他相关配置
})

axios.post(url[, data[, config]])

axios.post('demo/url', {
    id: 123,
    name: 'Henry',
},{
   timeout: 1000,
    ...//其他相关配置
})

axios.put(url[, data[, config]])

axios.put('demo/url', {
    id: 123,
    name: 'Henry',
},{
   timeout: 1000,
    ...//其他相关配置
})

axios.patch(url[, data[, config]])

axios.patch('demo/url', {
    id: 123,
    name: 'Henry',
},{
   timeout: 1000,
    ...//其他相关配置
})

get delete请求方式中，第一个参数为请求的url地址，第二个参数为请求的一些配置项，需要传递给后端的参数包含在配置项的data或者params属性中，而post put patch请求则第一个参数为url地址，第二个参数是需要入参的json数据，第三个参数是入参以外的其他配置项。


```

### vue多端口代理配置

```js
/**
 * 配置参考:
 * https://cli.vuejs.org/zh/config/
 */
// const url = 'http://pigx-gateway'
// const url = 'http://121.42.63.138:9999' //测试
const url = 'http://192.168.31.163:9999' //长龙
const url1 = 'http://192.168.31.163:6060' //长龙
const CompressionWebpackPlugin = require('compression-webpack-plugin')
const productionGzipExtensions = ['js', 'css']
module.exports = {

  lintOnSave: true,
  productionSourceMap: false,
  chainWebpack: config => {
    const entry = config.entry('app')
    entry
      .add('babel-polyfill')
      .end()
    entry
      .add('classlist-polyfill')
      .end()
  },
  css: {
    // 忽略 CSS order 顺序警告
    extract: { ignoreOrder: true }
  },
  configureWebpack: (config) => {
    if (process.env.NODE_ENV === 'production') {
      // 仅在生产环境下启用该配置
      return {
        performance: {
          // 打包后最大文件大小限制
          maxAssetSize: 1024000
        },
        plugins: [
          new CompressionWebpackPlugin({
            // filename: '[path].gz[query]',
            // algorithm: 'gzip',
            // test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
            // threshold: 1024, // 只有大小大于该值的资源会被处理,当前配置为对于超过1k的数据进行处理，不足1k的可能会越压缩越大
            // minRatio: 0.99, // 只有压缩率小于这个值的资源才会被处理
            // deleteOriginalAssets: true // 删除原文件
          })
        ]
      }
    }
  },
  // 配置转发代理
  devServer: {
    disableHostCheck: true,
    port: 8080,
    proxy: {
      '/api': {
        target: url1,
        // changeOrigin: true,
        ws: false,
        pathRewrite: {
            '^/api': '/'
        }
    },
    '/': {
      target: url,
      ws: false, // 需要websocket 开启
      pathRewrite: {
        '^/': '/'
      }
    },
      // 3.5 以后不需要再配置
    }
  }
}

```

### vue中mixins 的使用方法和注意点

混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

mixins 的特点：

1.方法和参数在各组件中不共享。

2.值为对象的选项，如methods，components等，选项会被合并，键冲突的组件会覆盖混入对象的

3.值为函数的选项，如created，mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用。

**与vuex的区别**

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任意组件中修改此变量的值之后，其他组件中此变量的值也会随之改变。

Mixins：可以定义公共变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

**与公共组件的区别**

组件：在父组件中引用组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于拓展了父组件的对象与方法，可以理解为形成了一个新的组件。

使用方法：

**定义一个混入对象**

![img](https://upload-images.jianshu.io/upload_images/10069417-662a06a665a12fd8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1070/format/webp)

**把混入对象混入到当前的组件中**

![img](https://upload-images.jianshu.io/upload_images/10069417-e1717df5de5fe031.png?imageMogr2/auto-orient/strip|imageView2/2/w/779/format/webp)

**方法以及变量的使用**

混合对象中的参数num

![img](https://upload-images.jianshu.io/upload_images/10069417-950eb20b788e1a14.png?imageMogr2/auto-orient/strip|imageView2/2/w/1070/format/webp)

组件1中的参数num进行+1的操作

![img](https://upload-images.jianshu.io/upload_images/10069417-c0f3c3051828fbf5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1042/format/webp)

组件2中的参数num未进行操作

![img](https://upload-images.jianshu.io/upload_images/10069417-f3592727f08b3db8.png?imageMogr2/auto-orient/strip|imageView2/2/w/904/format/webp)

分别输出

![img](https://upload-images.jianshu.io/upload_images/10069417-951e440b483654f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

混入对象的方法

![img](https://upload-images.jianshu.io/upload_images/10069417-7eb65d68e5f3ad23.png?imageMogr2/auto-orient/strip|imageView2/2/w/825/format/webp)

组件中的方法

![img](https://upload-images.jianshu.io/upload_images/10069417-4bb148ff01d43768.png?imageMogr2/auto-orient/strip|imageView2/2/w/1027/format/webp)

打印控制台的输出

![img](https://upload-images.jianshu.io/upload_images/10069417-1dbd24819335b26d.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

**混入对象的console**

![img](https://upload-images.jianshu.io/upload_images/10069417-8d9de93e376fea49.png?imageMogr2/auto-orient/strip|imageView2/2/w/749/format/webp)

组件函数中的console

![img](https://upload-images.jianshu.io/upload_images/10069417-e7d281e45b2a6274.png?imageMogr2/auto-orient/strip|imageView2/2/w/743/format/webp)

控制台的打印

![img](https://upload-images.jianshu.io/upload_images/10069417-4e01bb1cadb4055a.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

### rendless

1，什么是rendless？

```js
1.什么是render函数
	众所周知，在工程中我们会在.vue中定义<template>,<script>,<style>三种tag，分别盛放组件html,javascript和css。
	但事实上，最后在生产环境中，我们只使用了一个巨大的JS文件，究其缘由还是得益于webpack的 vue loader
    vue.js会把template元素提取出来，并且进一步编译成一个交render的函数。例如
        render(h) {
          return h(
            'button',
            {class: 'mood'},
            state ? 'On' : 'Off'
          )
        }
	render函数最后会被vue优化成VNode（虚节点），同时在编写组件时，我们其实可以不写template只需要写render函数。
    例如：
const button = {
  render(h) {
    return h(
    'button',
          {class: 'mood'},
    state ? 'On' : 'Off'
        )
  },
  data() {
    return {state: false}
  }
}
```

2.**Renderless component 概念**

直译的话应该交非渲染组件。

Renderless意思就是组件**只提供数据操作，不渲染任何内容**。

```js
const toggle = {
    render() {
    },
data() {
return { state: true }
    },
    methods: {
        toggle() {
this.state = !this.state
        }
    }
}

new Vue({
    el: '#parent',
    components: { toggle },
    ...
})
    
    toggle就是所谓的Renderless组件了，只有数据和方法，不提供html template。父组件直接将其放入components即可当作一般子组件使用
```

### **3** **Renderless 示例**

Renderless 组件不渲染，那谁负责渲染工作呢？嗯，就是Slots！父组件通过传递自定义的slots来定制子组件的html template。

```js
<toggle v-slot:default="{on, toggle}">
    <div class="container">
        <button @click="click(toggle)">
            {{on ? 'On' : 'Off'}}
        </button>
    </div>
</toggle>
```

这里提一下v-slot，它是**vue 2.6以后的新语法**，用来代替之前的 slot 和 slot-scope；**v-slot:default 还可以简写成 #default**。Vue3应该不会再保留 slot 和 slot-scope 这种不伦不类的标签了。

最后我们在父组件调用renderless组件：

```js
<template>
  <toggle v-slot="{on, toggle}">
        <div class="container">
        <button @click="click(toggle)">
                        {{on ? 'On' : 'Off'}}
        </button>
        </div>
  </toggle>
</template>

<script>
import toggle from 'toggle';

export default {
components: { toggle },
methods: {
        click(fn) {
            fn()
        },
    },
}

```

假如你想自定义组件样式，或是说控制toggle渲染方式，更改也很容易，只需要在插槽里写下自定义代码即可：

```

<toggle #default="{ on, toggle  }">
    <div class="container">
    <button @click="click(toggle)"
    :style="{background: on ? 'green' : 'red'}">
                {{on ? 'On' : 'Off'}}
    </button>
    </div>
</toggle>
```

因为toggle的逻辑不变，所以我们不需要更改这个renderless组件。只需稍微改动一下slot，button的背景色就会随着开关一起改变了。

**嗯，这就是Renderless组件的效果，功能逻辑和页面渲染分开。**

